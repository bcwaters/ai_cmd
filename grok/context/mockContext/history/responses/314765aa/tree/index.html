<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Home Page</title>
</head>
<body>
  <nav>
    <button id="saveButton" onclick="saveButton()">Save html</button>
    <a id="parentContent" href='javascript:goHomePage()'>Home</a>
    <select id="childSubjects">
      <option value="home">Home</option>
      <!-- Children are added here onload with setChildSubjects -->
    </select>
    <!-- Add a previous and next button for prior requests? -->
    <!-- Add a button to save the current page as a markdown file -->
  </nav>

  <div id="content">  
    <div id="parentContent">
        <p>Here are three useful regular expressions for ensuring a properly formatted string, along with explanations of their uses:</p>
<h3>1. Email Validation</h3>
<p><strong>Regex Pattern:</strong></p>
<pre><code class="language-regex">^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$
</code></pre>
<p><strong>Explanation:</strong>
This regex pattern is used to validate email addresses. It ensures that the string contains:</p>
<ul>
<li>One or more characters for the username part (before the <code>@</code>), which can include letters, numbers, and certain special characters (<code>._%+-</code>).</li>
<li>An <code>@</code> symbol separating the username from the domain.</li>
<li>One or more characters for the domain part, which can include letters, numbers, and dots (<code>.</code>).</li>
<li>A dot (<code>.</code>) followed by the top-level domain, which must be at least two characters long.</li>
</ul>
<p><strong>Use Case:</strong>
To check if an input string is a valid email address.</p>
<h3>2. Password Strength</h3>
<p><strong>Regex Pattern:</strong></p>
<pre><code class="language-regex">^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&amp;*])[A-Za-z\d!@#$%^&amp;*]{8,}$
</code></pre>
<p><strong>Explanation:</strong>
This regex pattern is designed to check for password strength. It ensures that the password:</p>
<ul>
<li>Contains at least one lowercase letter (<code>[a-z]</code>).</li>
<li>Contains at least one uppercase letter (<code>[A-Z]</code>).</li>
<li>Contains at least one digit (<code>\d</code>).</li>
<li>Contains at least one special character from the set <code>!@#$%^&amp;*</code>.</li>
<li>Is at least 8 characters long.</li>
</ul>
<p><strong>Use Case:</strong>
To enforce a strong password policy, ensuring the password meets complexity requirements.</p>
<h3>3. URL Validation</h3>
<p><strong>Regex Pattern:</strong></p>
<pre><code class="language-regex">^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$
</code></pre>
<p><strong>Explanation:</strong>
This regex pattern is used to validate URLs. It checks for:</p>
<ul>
<li>An optional <code>http://</code> or <code>https://</code> at the beginning.</li>
<li>A domain name composed of letters, numbers, dots, and hyphens.</li>
<li>A top-level domain (TLD) of 2 to 6 characters.</li>
<li>An optional path after the domain, which can include letters, numbers, dots, hyphens, and slashes.</li>
</ul>
<p><strong>Use Case:</strong>
To validate whether an input string is a properly formatted URL.</p>
<p>These regex patterns can be used in various programming languages and tools to ensure that strings meet specific formatting criteria.</p>

    </div>
    <div id="childDivs">
      <div title=""Email Validation" id="childContent1" onclick="setVisibileChild('childContent1')" hidden=true><h1>Email Validation</h1>
<p>Email validation is a critical aspect of web development and user input processing. Here's a detailed breakdown of the aspects previously mentioned:</p>
<h2>Regular Expressions (Regex) for Email Validation</h2>
<p>Using regular expressions is a common method to validate email addresses. A typical regex pattern for email validation might look like this:</p>
<pre><code class="language-regex">^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$
</code></pre>
<p>This pattern ensures that an email address has:</p>
<ul>
<li>A username part before the <code>@</code> symbol, which can contain letters, numbers, and certain special characters.</li>
<li>A domain name part after the <code>@</code> symbol, which must include at least one dot and end with a top-level domain of at least two characters.</li>
</ul>
<h2>Validation Process</h2>
<p>The validation process involves several steps:</p>
<ol>
<li><strong>Syntax Check</strong>: The regex pattern is used to check if the email address follows the correct format.</li>
<li><strong>Domain Verification</strong>: Optionally, the domain part of the email can be checked for existence by attempting to resolve the DNS.</li>
<li><strong>Mailbox Verification</strong>: This is a more advanced step where the system might attempt to send a confirmation email to verify if the mailbox exists.</li>
</ol>
<h2>Importance of Email Validation</h2>
<ul>
<li><strong>Security</strong>: Validating emails helps prevent spam and phishing attacks by ensuring that only legitimate email addresses are accepted.</li>
<li><strong>User Experience</strong>: Proper validation reduces the chances of users entering incorrect email addresses, which can lead to issues with account creation or password recovery.</li>
<li><strong>Data Integrity</strong>: Ensuring that the emails in your database are valid improves the quality of your data and the effectiveness of email campaigns.</li>
</ul>
<h2>Tools and Libraries</h2>
<p>Several tools and libraries can be used for email validation:</p>
<ul>
<li><strong>Client-side Validation</strong>: JavaScript libraries like jQuery Validation can be used to validate email addresses before form submission.</li>
<li><strong>Server-side Validation</strong>: Languages like Python, PHP, and Node.js have built-in or third-party libraries for email validation. For example, in Python, you might use the <code>email-validator</code> package.</li>
</ul>
<h2>Best Practices</h2>
<ul>
<li><strong>Comprehensive Validation</strong>: Use both client-side and server-side validation to ensure robustness.</li>
<li><strong>Feedback to Users</strong>: Provide clear and immediate feedback to users if their email address is invalid.</li>
<li><strong>Regular Updates</strong>: Keep your validation methods updated to handle new email formats and standards.</li>
</ul>
<p>By focusing on these aspects of email validation, you can significantly enhance the security and usability of your applications.</p>
<p>ResponseID:f57be153</p>
</div><div title=" Password Strength" id="childContent2" onclick="setVisibileChild('childContent2')" hidden=true><h1>Password Strength</h1>
<p>When discussing password strength, it's essential to consider several key factors that contribute to the security and robustness of a password. Here's a detailed breakdown of the aspects previously mentioned:</p>
<h2>Complexity</h2>
<p>Password complexity is crucial for enhancing security. A strong password typically includes a mix of the following elements:</p>
<ul>
<li><strong>Uppercase letters (A-Z)</strong>: Including at least one uppercase letter adds complexity.</li>
<li><strong>Lowercase letters (a-z)</strong>: Combining with uppercase letters increases the possible combinations.</li>
<li><strong>Numbers (0-9)</strong>: Adding numbers further diversifies the character set.</li>
<li><strong>Special characters (!@#$%^&amp;*()_+)</strong>: Incorporating symbols significantly increases the complexity.</li>
</ul>
<h2>Length</h2>
<p>The length of a password is another vital factor. Generally, longer passwords are more secure because they increase the number of possible combinations an attacker would need to try. A minimum of 12 characters is often recommended, but longer is better.</p>
<h2>Unpredictability</h2>
<p>A strong password should be unpredictable and avoid common patterns or easily guessable information. This means avoiding:</p>
<ul>
<li><strong>Dictionary words</strong>: Using common words makes passwords vulnerable to dictionary attacks.</li>
<li><strong>Personal information</strong>: Names, birthdays, or other personal details should be avoided.</li>
<li><strong>Sequential patterns</strong>: Patterns like "1234" or "abcd" are easily guessed.</li>
</ul>
<h2>Examples of Strong Passwords</h2>
<p>Here are a few examples of strong passwords:</p>
<ul>
<li><code>Jk7$Lm!23Pq</code></li>
<li><code>Wf#89rT&amp;6yZx</code></li>
<li><code>Hg@45sD^12vB</code></li>
</ul>
<p>These passwords combine length, complexity, and unpredictability, making them much harder to crack.</p>
<h2>Tools for Validation</h2>
<p>To ensure a password meets these criteria, various tools and algorithms can be used:</p>
<ul>
<li><strong>Regex patterns</strong>: These can be employed to check for the presence of required character types and length.</li>
<li><strong>Password strength meters</strong>: Many websites use these to provide real-time feedback on password strength.</li>
<li><strong>Password managers</strong>: These tools often generate strong, random passwords and can check the strength of user-created passwords.</li>
</ul>
<p>By focusing on these aspects, you can significantly enhance the security of your passwords, making them more resistant to brute-force attacks and unauthorized access.</p>
<p>ResponseID:92ded8d1</p>
</div><div title=" URL Validation"" id="childContent3" onclick="setVisibileChild('childContent3')" hidden=true><h3>URL Validation Regex Pattern</h3>
<p><strong>Regex Pattern:</strong> <code>regexhttps?://[a-z0-9.-]+/[a-z0-9-._~:/?#[\]@!@REPLACEWITHCHILDRENDIVS@amp;'()*+,;=]*$</code></p>
<p><strong>Explanation:</strong> This regex pattern is used to validate URLs. Let's break down its components and functionality:</p>
<ul>
<li><p><strong>Protocol:</strong> <code>https?://</code> - This part of the regex checks for the presence of either <code>http://</code> or <code>https://</code> at the beginning of the URL. The <code>?</code> after <code>s</code> makes it optional, allowing for both HTTP and HTTPS protocols.</p>
</li>
<li><p><strong>Domain Name:</strong> <code>[a-z0-9.-]+</code> - This segment validates the domain name of the URL. It allows for alphanumeric characters (<code>a-z0-9</code>), dots (<code>.</code>), and hyphens (<code>-</code>). The <code>+</code> indicates that at least one of these characters must be present.</p>
</li>
<li><p><strong>Path and Query:</strong> <code>/[a-z0-9-._~:/?#[\]@!@REPLACEWITHCHILDRENDIVS@amp;'()*+,;=]*$</code> - This part checks for any path or query string following the domain name. It allows for a wide range of characters that are commonly used in URLs, such as letters, numbers, and various special characters. The <code>*</code> at the end indicates that these characters can appear zero or more times, and the <code>$</code> ensures that the pattern matches until the end of the string.</p>
</li>
</ul>
<p><strong>Usage:</strong> This pattern can be used in various programming languages and tools to ensure that a given string meets the criteria for a properly formatted URL. It's particularly useful in web development for validating user input, filtering data, or ensuring that links within a website or application are correctly formatted.</p>
<p><strong>Example Use Case:</strong> When a user submits a URL on a website, this regex can be applied to check if the input is a valid URL. If the URL passes the validation, the website can proceed to process it further, perhaps by redirecting to the URL or storing it in a database. If the URL fails the validation, the website can prompt the user to enter a correctly formatted URL.</p>
<p>By using this regex pattern, developers can ensure that their applications handle URLs correctly, enhancing user experience and maintaining data integrity.</p>
<p>ResponseID:9669121e</p>
</div>
    </div>
  </div>

    <script>
        function saveButton() {
          const content = document.documentElement.outerHTML; // Get the entire HTML content
          const blob = new Blob([content], { type: 'text/html' }); // Create a Blob from the content
          const url = URL.createObjectURL(blob); // Create a URL for the Blob
          const divInnerText = document.getElementById('content').innerText;
          let filename = divInnerText.substring(0, 25);
          const a = document.createElement('a'); // Create an anchor element
          a.href = url; // Set the href to the Blob URL
          
        a.download =  filename + '.html'; // Set the download attribute with a filename
          document.body.appendChild(a); // Append the anchor to the body
          a.click(); // Programmatically click the anchor to trigger the download
          document.body.removeChild(a); // Remove the anchor from the document
          URL.revokeObjectURL(url); // Release the Blob URL
        }
    </script>

    <script>
      function setChildSubjects(){
        let dropDownOptions = [];
        let childSubjects = document.getElementById('childDivs');
        for (let child of childSubjects.children){
           let subject = child.title;
           let optionValue = child.id;

           dropDownOptions.push({subject: subject, value: optionValue});
        
        }

        for (let option of dropDownOptions){
          let optionElement = document.createElement('option');
          optionElement.value = option.value;
          optionElement.text = option.subject;
          document.getElementById('childSubjects').appendChild(optionElement);
        }

        document.getElementById('childSubjects').addEventListener('change', function() {
          if(this.value == "home"){
            goHomePage();
          }else{
            setVisibileChild(this.value);
          }

          }
        );
      }
    </script>


    <script>
      function setVisibleChild(id){
        //quick flicker home to reset state, this allows hoping between child views
     
         if(id != "parentContent"){
           let topNode = document.getElementById('content');
           let parentNode = document.getElementById('parentContent');
           let childVisibleNode = document.getElementById(id);
           let childDivs = document.getElementById('childDivs');
           for (let child of childDivs.children){
            if(child.id != id){
              child.hidden = true;
            }else{
              child.hidden = false; //redudant
            }
           }
           parentNode.hidden = true;
           childVisibleNode.hidden = false;
         }
      }
    </script>

    <script>
      function goHomePage(){
         let topNode = document.getElementById('content');
         let parentNode = document.getElementById('parentContent');
         let children = document.getElementById('childDivs');
         for (let child of children.children){
            child.hidden = true;
         }
         parentNode.hidden = false;
      }
    </script>

    <script>
      function setChildLinks(){
        let children = document.getElementById('childDivs'); 
        let childSubjects = [];
        let discoveredMatches = [];

        
        for (let child of children.children){
          let subject = child.title;
          childSubjects.push({subject: subject, child: child});
          }
             
          let parentNodeH2Subjects = []
          let parentNodeH3Subjects = []
          let parentNodeH4Subjects = []
          let parentNode = document.getElementById('parentContent');
          let H2s = parentNode.getElementsByTagName("H2");
          let H3s = parentNode.getElementsByTagName("H3");
          let H4s = parentNode.getElementsByTagName("H4");
          let isH2Match = false;
          let isH3Match = false;
          let isH4Match = false;

          H2s.length > 0? parentNodeH2Subjects = H2s.map(item => ({subject: item.innerText, item: item})):isH2Match = false;
          H3s.length > 0?parentNodeH3Subjects = H3s.map(item => ({subject: item.innerText, item: item})):isH3Match = false;
          H4s.length > 0?parentNodeH4Subjects = H4s.map(item => ({subject: item.innerText, item: item})):isH4Match = false;

          
           isH3Match = H3s.length == childSubjects.length;
           isH2Match = H2s.length == childSubjects.length;
           isH4Match = H4s.length == childSubjects.length;
          let allDiscovered = false;

          if (isH3Match){
            //We have a match.  We need to find the H2s
            allDiscovered = true;
          }
          if (isH2Match){
            //We have a match.  We need to find the H3s
            allDiscovered = true;
          }
          if (isH4Match){
            //We have a match.  We need to find the H2s
            allDiscovered = true;
          }

          if(allDiscovered && (isH3Match + isH2Match + isH4Match) > 1){
            //wierd.  ok we work from scratch.
            allDiscovered = false;
          }

          if(!allDiscovered){

            let fluffWords = ["a", "an", "the", "and", "but", "or", "for", "nor", "on", "at", "to", "from", "by", "with", "of"];
            let fluffWordsRegex = new RegExp(fluffWords.join("|"), "g");
          
          //OK time to stumble through unpredictable llm output
          //First check if the child subjects are in the parent node h2 subjects
          let isH2 = false;
          let isH3 = false;
          let isH4 = false;
      
          //This can be optimized later.  Probably doesnt matter since it is client side with modern computing.
          for (let i = 0; i < parentNodeH2Subjects.length; i++){
            let subject = parentNodeH2Subjects[i].subject;
            for (let j = 0; j < childSubjects.length; j++){
              let childSubject = childSubjects[j].subject;
              if(childSubject.replace(fluffWordsRegex, "") == subject.replace(fluffWordsRegex, "")){
                isH2 = true;
                discoveredMatches.push({parentLink: parentNodeH2Subjects[i].item, childLink: childSubjects[j].child});
              }
            }

          }
         
          if(!isH2){
            for (let i = 0; i < parentNodeH3Subjects.length; i++){
              let subject = parentNodeH3Subjects[i].subject;
              for (let j = 0; j < childSubjects.length; j++){
                let childSubject = childSubjects[j].subject;  
                if(childSubject.replace(fluffWordsRegex, "") == subject.replace(fluffWordsRegex, "")){
                  isH3 = true;
                  discoveredMatches.push({parentLink: parentNodeH3Subjects[i].item, childLink: childSubjects[j].child});
                }
              }
            }
          }

          if(!isH3){
            for (let i = 0; i < parentNodeH4Subjects.length; i++){
              let subject = parentNodeH4Subjects[i].subject;
              for (let j = 0; j < childSubjects.length; j++){
                let childSubject = childSubjects[j].subject;
                if(childSubject.replace(fluffWordsRegex, "") == subject.replace(fluffWordsRegex, "")){
                  isH4 = true;
                  discoveredMatches.push({parentLink: parentNodeH4Subjects[i].item, childLink: childSubjects[j].child});
                }
              }
            }
          }

          if(!isH4){
              //I suppose there are edge cases but this surely covers 99.9% of the cases.
          }

          }else{
            if(isH3Match){
              for (let i = 0; i < parentNodeH3Subjects.length; i++){
                let child = childSubjects[i].child;
                makeChildLinks(parentNodeH3Subjects[i].item, child);
              }
              return; //bye bye
            }
            if(isH2Match){
              for (let i = 0; i < parentNodeH2Subjects.length; i++){
                let child = childSubjects[i].child;
                makeChildLinks(parentNodeH2Subjects[i].item, child);
                return; //bye bye
              }
              if(isH4Match){
                for (let i = 0; i < parentNodeH4Subjects.length; i++){
                  let child = childSubjects[i].child;
                  makeChildLinks(parentNodeH4Subjects[i].item, child);
                }
              }

            }

          }

          for (let match of discoveredMatches){
            makeChildLinks(match.parentLink, match.childLink);
            if(match.length < childSubjects.length){ alert("LLMM added additional info that is hidden");}
          }

        }
    </script>

    <script>
       function makeChildLinks(parent, child){
            parent.style.cursor = "pointer";
            parent.style.textDecoration = "underline";
            parent.style.color = "blue";
            parent.onclick = function(){
              setVisibleChild(child.id);
            }
       }

    </script>

<script>window.onload = setChildSubjects;</script>

</body>
</html>


   
    <!-- <textarea id="userPrompt"></textarea>

    <script>
        function nextButton() {
            const userPrompt = document.getElementById('userPrompt').value;
            console.log(userPrompt);
        }
    </script> -->