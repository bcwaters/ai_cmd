<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Home Page</title>
</head>
<body>
  <nav>
    <button id="saveButton" onclick="saveButton()">Save html</button>
    <a id="home" href='javascript:goHomePage()'>Home</a>
    <!-- Add a previous and next button for prior requests? -->
    <!-- Add a button to save the current page as a markdown file -->
  </nav>

  <div id="content">  
    <div id="parentContent">
        <p>Here are two syntax facts about regular expressions (regex):</p>
<ol>
<li><p><strong>Character Classes</strong>:</p>
<ul>
<li>In regex, character classes are defined using square brackets <code>[]</code>. For example, <code>[abc]</code> matches any single character <code>a</code>, <code>b</code>, or <code>c</code>. You can also use ranges, such as <code>[a-z]</code> to match any lowercase letter from <code>a</code> to <code>z</code>.</li>
</ul>
</li>
<li><p><strong>Quantifiers</strong>:</p>
<ul>
<li>Quantifiers specify how many times a character or group should be matched. For instance, <code>*</code> means zero or more occurrences, <code>+</code> means one or more occurrences, and <code>?</code> means zero or one occurrence. For example, <code>a*</code> matches zero or more <code>a</code>s, and <code>a+</code> matches one or more <code>a</code>s.</li>
</ul>
</li>
</ol>

    </div>
    <div id="childDivs">
      <div title=""Character Classes" id="childContent1" onclick="setVisibileChild('childContent1')" hidden=true><h1>Character Classes in Regular Expressions</h1>
<p>Character classes are a fundamental concept in regular expressions (regex) that allow you to define a set of characters you want to match within a string. They are enclosed in square brackets <code>[]</code> and let you specify a group of characters where any single character from the group will satisfy the match. Here's a more detailed look at character classes:</p>
<h3>Basic Character Classes</h3>
<ul>
<li><strong>Single Character Match</strong>: Inside square brackets, you can list any number of characters. For example, <code>[abc]</code> will match any single occurrence of 'a', 'b', or 'c'.</li>
<li><strong>Range of Characters</strong>: You can specify a range of characters using a hyphen. For instance, <code>[a-z]</code> matches any lowercase letter from 'a' to 'z', and <code>[0-9]</code> matches any digit from 0 to 9.</li>
<li><strong>Negation</strong>: By placing a caret <code>^</code> at the start of the character class, you can match any character that is not listed. For example, <code>[^abc]</code> will match any character except 'a', 'b', or 'c'.</li>
</ul>
<h3>Special Character Classes</h3>
<p>Regex also provides predefined character classes for common sets of characters:</p>
<ul>
<li><strong>Digits</strong>: <code>\d</code> matches any digit, equivalent to <code>[0-9]</code>.</li>
<li><strong>Word Characters</strong>: <code>\w</code> matches any word character (alphanumeric characters plus underscore), equivalent to <code>[a-zA-Z0-9_]</code>.</li>
<li><strong>Whitespace</strong>: <code>\s</code> matches any whitespace character, including spaces, tabs, and line breaks.</li>
</ul>
<h3>Combining Character Classes with Quantifiers</h3>
<p>Character classes can be combined with quantifiers to specify how many times a character from the class should appear. For example:</p>
<ul>
<li><code>[a-z]+</code> matches one or more lowercase letters.</li>
<li><code>\d{3}</code> matches exactly three digits.</li>
</ul>
<h3>Use Cases</h3>
<p>Character classes are incredibly versatile and can be used for a variety of text matching and manipulation tasks:</p>
<ul>
<li><strong>Validation</strong>: Ensuring input strings conform to specific formats, like email addresses or phone numbers.</li>
<li><strong>Data Extraction</strong>: Pulling specific types of data from unstructured text, such as numbers or dates.</li>
<li><strong>Text Cleaning</strong>: Removing or replacing unwanted characters or standardizing text formats.</li>
</ul>
<p>Understanding and effectively using character classes can greatly enhance your ability to perform complex text matching and manipulation tasks with regex.</p>
<p>ResponseID:bb984b2d</p>
</div><div title=" Quantifiers"" id="childContent2" onclick="setVisibileChild('childContent2')" hidden=true><h1>Quantifiers in Regular Expressions</h1>
<p>Quantifiers are crucial components of regular expressions (regex) that allow you to specify how many times a character or a group of characters should occur in a match. Here's a detailed look at the quantifiers mentioned previously and some additional ones:</p>
<ul>
<li><p><strong>Zero or More (<code>*</code>)</strong>: The asterisk <code>*</code> is used to indicate that the preceding character or group can appear zero or more times. For example, the pattern <code>a*</code> matches an empty string or any sequence of the letter 'a'. It's important to note that this quantifier can lead to greedy matching, where the regex engine tries to match as many characters as possible.</p>
</li>
<li><p><strong>One or More (<code>+</code>)</strong>: The plus sign <code>+</code> indicates that the preceding character or group must appear at least once and can appear multiple times. For example, <code>a+</code> will match 'a', 'aa', 'aaa', and so on, but not an empty string. Like <code>*</code>, <code>+</code> is also greedy by default.</p>
</li>
<li><p><strong>Zero or One (<code>?</code>)</strong>: The question mark <code>?</code> specifies that the preceding character or group can appear zero times or once. For example, <code>colou?r</code> will match both 'color' and 'colour'. This quantifier is useful for matching optional characters.</p>
</li>
</ul>
<h3>Additional Quantifiers:</h3>
<ul>
<li><p><strong>Exact Number (<code>{n}</code>)</strong>: This quantifier specifies that the preceding character or group should occur exactly <code>n</code> times. For example, <code>a{3}</code> will match exactly three 'a's.</p>
</li>
<li><p><strong>Range (<code>{n,m}</code>)</strong>: This allows you to specify a range of occurrences. The preceding character or group should appear at least <code>n</code> times and at most <code>m</code> times. For example, <code>a{2,4}</code> will match 'aa', 'aaa', and 'aaaa'.</p>
</li>
<li><p><strong>At Least (<code>{n,}</code>)</strong>: This specifies that the preceding character or group should occur at least <code>n</code> times. For example, <code>a{2,}</code> will match 'aa', 'aaa', 'aaaa', and so on.</p>
</li>
<li><p><strong>Non-Greedy Quantifiers</strong>: By adding a <code>?</code> after any of the above quantifiers, you can make them non-greedy. This means they will match as few characters as possible. For example, <code>a*?</code> will match an empty string or the first 'a' it encounters, rather than all 'a's.</p>
</li>
</ul>
<p>Understanding and using quantifiers effectively can greatly enhance your ability to perform complex text matching and manipulation tasks with regex.</p>
<p>ResponseID:7adf2ba8</p>
</div>
    </div>
  </div>

    <script>
        function saveButton() {
          const content = document.documentElement.outerHTML; // Get the entire HTML content
          const blob = new Blob([content], { type: 'text/html' }); // Create a Blob from the content
          const url = URL.createObjectURL(blob); // Create a URL for the Blob
          const divInnerText = document.getElementById('content').innerText;
          let filename = divInnerText.substring(0, 25);
          const a = document.createElement('a'); // Create an anchor element
          a.href = url; // Set the href to the Blob URL
          
        a.download =  filename + '.html'; // Set the download attribute with a filename
          document.body.appendChild(a); // Append the anchor to the body
          a.click(); // Programmatically click the anchor to trigger the download
          document.body.removeChild(a); // Remove the anchor from the document
          URL.revokeObjectURL(url); // Release the Blob URL
        }
    </script>

    <script>
      function setVisibileChild(id){
         let topNode = document.getElementById('content');
         let parentNode = document.getElementById('parentContent');
         let childVisibleNode = document.getElementById(id);
         parentNode.hidden = true;
         childVisibleNode.hidden = false;
      }
    </script>

    <script>
      function goHomePage(){
         let topNode = document.getElementById('content');
         let parentNode = document.getElementById('parentContent');
         let children = document.getElementById('childDivs');
         for (let child of children.children){
            child.hidden = true;
         }
         parentNode.hidden = false;
      }
    </script>

    <script>
      function setChildLinks(){
        let children = document.getElementById('childDivs'); 
        let childSubjects = [];
        let discoveredMatches = [];

        
        for (let child of children.children){
          let subject = child.title;
          childSubjects.push({subject: subject, child: child});
          }
             
          let parentNodeH2Subjects = []
          let parentNodeH3Subjects = []
          let parentNode = document.getElementById('parentContent');
          let H2s = parentNode.getElementsByTagName("H2");
          let H3s = parentNode.getElementsByTagName("H3");
          let H4s = parentNode.getElementsByTagName("H4");
          
          let isH3Match = H3s.length == childSubjects.length;
          let isH2Match = H2s.length == childSubjects.length;
          let isH4Match = H4s.length == childSubjects.length;
          let allDiscovered = false;

          if (isH3Match){
            //We have a match.  We need to find the H2s
            allDiscovered = true;
          }
          if (isH2Match){
            //We have a match.  We need to find the H3s
            allDiscovered = true;
          }
          if (isH4Match){
            //We have a match.  We need to find the H2s
            allDiscovered = true;
          }

          if(allDiscovered && (isH3Match + isH2Match + isH4Match) > 1){
            //wierd.  ok we work from scratch.
            allDiscovered = false;
          }

          if(!allDiscovered){

            let fluffWords = ["a", "an", "the", "and", "but", "or", "for", "nor", "on", "at", "to", "from", "by", "with", "of"];
            let fluffWordsRegex = new RegExp(fluffWords.join("|"), "g");
          for (let item of H2s){
            let subject = item.innerText;
              parentNodeH2Subjects.push({subject: subject, item: item});

            }

            if(item.tagName == "H3" ){
              let subject = item.innerText;
              parentNodeH3Subjects.push({subject: subject, item: item});

            }
          
          //OK time to stumble through unpredictable llm output
          //First check if the child subjects are in the parent node h2 subjects
          let isH2 = false;
          let isH3 = false;
          let isH4 = false;
      


          //This can be optimized later.  Probably doesnt matter since it is client side with modern computing.
          for (let i = 0; i < parentNodeH2Subjects.length; i++){
            let subject = parentNodeH2Subjects[i].subject;
            for (let j = 0; j < childSubjects.length; j++){
              let childSubject = childSubjects[j].subject;
              if(childSubject.replace(fluffWordsRegex, "") == subject.replace(fluffWordsRegex, "")){
                isH2 = true;
                discoveredMatches.push({parentLink: parentNodeH2Subjects[i].item, childLink: childSubjects[j].child});
              }
            }

          }
         
          if(!isH2){
            for (let i = 0; i < parentNodeH3Subjects.length; i++){
              let subject = parentNodeH3Subjects[i].subject;
              for (let j = 0; j < childSubjects.length; j++){
                let childSubject = childSubjects[j].subject;  
                if(childSubject.replace(fluffWordsRegex, "") == subject.replace(fluffWordsRegex, "")){
                  isH3 = true;
                  discoveredMatches.push({parentLink: parentNodeH3Subjects[i].item, childLink: childSubjects[j].child});
                }
              }
            }
          }

          if(!isH3){
            for (let i = 0; i < parentNodeH4Subjects.length; i++){
              let subject = parentNodeH4Subjects[i].subject;
              for (let j = 0; j < childSubjects.length; j++){
                let childSubject = childSubjects[j].subject;
                if(childSubject.replace(fluffWordsRegex, "") == subject.replace(fluffWordsRegex, "")){
                  isH4 = true;
                  discoveredMatches.push({parentLink: parentNodeH4Subjects[i].item, childLink: childSubjects[j].child});
                }
              }
            }
          }

          if(!isH4){
              //I suppose there are edge cases but this surely covers 99.9% of the cases.
          }

          }else{
            if(isH3Match){
              for (let i = 0; i < parentNodeH3Subjects.length; i++){
                let child = childSubjects[i].child;
                makeChildLinks(parentNodeH3Subjects[i].item, child);
              }
              return; //bye bye
            }
            if(isH2Match){
              for (let i = 0; i < parentNodeH2Subjects.length; i++){
                let child = childSubjects[i].child;
                makeChildLinks(parentNodeH2Subjects[i].item, child);
                return; //bye bye
              }
              if(isH4Match){
                for (let i = 0; i < parentNodeH4Subjects.length; i++){
                  let child = childSubjects[i].child;
                  makeChildLinks(parentNodeH4Subjects[i].item, child);
                }
              }

            }

          }

          for (let match of discoveredMatches){
            makeChildLinks(match.parentLink, match.childLink);
            if(match.length < childSubjects.length){ alert("LLMM added additional info that is hidden");}
          }

        }
    </script>

    <script>
       function makeChildLinks(parent, child){
            parent.style.cursor = "pointer";
            parent.style.textDecoration = "underline";
            parent.style.color = "blue";
            parent.onclick = function(){
              setVisibileChild(child.id);
            }
       }

    </script>

<script>window.onload = setChildLinks;</script>

</body>
</html>


   
    <!-- <textarea id="userPrompt"></textarea>

    <script>
        function nextButton() {
            const userPrompt = document.getElementById('userPrompt').value;
            console.log(userPrompt);
        }
    </script> -->