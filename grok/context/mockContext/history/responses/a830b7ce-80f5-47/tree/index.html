<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Home Page</title>
  <style>
    
html {
  font-size: 100%;
  overflow-y: scroll;
  -webkit-text-size-adjust: 100%;
  -ms-text-size-adjust: 100%;
}

body {
  color: #444;
  font-family: Georgia, Palatino, 'Palatino Linotype', Times, 'Times New Roman', serif;
  font-size: 12px;
  line-height: 1.5em;
  padding: 1em;
  margin: auto;
  max-width: 50em;
  background: #fefefe;
}

a {
  color: #0645ad;
  text-decoration: none;
}

a:visited {
  color: #0b0080;
}

a:hover {
  color: #06e;
}

a:active {
  color: #faa700;
}

a:focus {
  outline: thin dotted;
}

a:hover,
a:active {
  outline: 0;
}

::-moz-selection {
  background: rgba(255, 255, 0, 0.3);
  color: #000;
}

::selection {
  background: rgba(255, 255, 0, 0.3);
  color: #000;
}

a::-moz-selection {
  background: rgba(255, 255, 0, 0.3);
  color: #0645ad;
}

a::selection {
  background: rgba(255, 255, 0, 0.3);
  color: #0645ad;
}

p {
  margin: 1em 0;
}

img {
  max-width: 100%;
}

h1,
h2,
h3,
h4,
h5,
h6 {
  font-weight: normal;
  color: #111;
  line-height: 1em;
}

h4,
h5,
h6 {
  font-weight: bold;
}

h1 {
  font-size: 2.5em;
}

h2 {
  font-size: 2em;
}

h3 {
  font-size: 1.5em;
}

h4 {
  font-size: 1.2em;
}

h5 {
  font-size: 1em;
}

h6 {
  font-size: 0.9em;
}

blockquote {
  color: #666666;
  margin: 0;
  padding-left: 3em;
  border-left: 0.5em #eee solid;
}

hr {
  display: block;
  border: 0;
  border-top: 1px solid #aaa;
  border-bottom: 1px solid #eee;
  margin: 1em 0;
  padding: 0;
}

/* pre,
code, */
kbd,
samp {
  color: #000;
  font-family: monospace, monospace;
  _font-family: 'courier new', monospace;
  font-size: 0.98em;
}

pre {
  white-space: pre;
  white-space: pre-wrap;
  word-wrap: break-word;
}

b,
strong {
  font-weight: bold;
}

dfn {
  font-style: italic;
}

ins {
  background: #ff9;
  color: #000;
  text-decoration: none;
}

mark {
  background: #ff0;
  color: #000;
  font-style: italic;
  font-weight: bold;
}

sub,
sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}

sup {
  top: -0.5em;
}

sub {
  bottom: -0.25em;
}

ul,
ol {
  margin: 1em 0;
  padding: 0 0 0 2em;
}

li p:last-child {
  margin: 0;
}

dd {
  margin: 0 0 0 2em;
}

img {
  border: 0;
  -ms-interpolation-mode: bicubic;
  vertical-align: middle;
}

table {
  border-collapse: collapse;
  border-spacing: 0;
}

td {
  vertical-align: top;
}

@media only screen and (min-width: 480px) {
  body {
    font-size: 14px;
  }
}

@media only screen and (min-width: 768px) {
  body {
    font-size: 16px;
  }
}

@media print {
  * {
    background: transparent !important;
    color: black !important;
    filter: none !important;
    -ms-filter: none !important;
  }

  body {
    font-size: 12pt;
    max-width: 100%;
  }

  a,
  a:visited {
    text-decoration: underline;
  }

  hr {
    height: 1px;
    border: 0;
    border-bottom: 1px solid black;
  }

  a[href]:after {
    content: " (" attr(href) ")";
  }

  abbr[title]:after {
    content: " (" attr(title) ")";
  }

  .ir a:after,
  a[href^="javascript:"]:after,
  a[href^="#"]:after {
    content: "";
  }

  pre,
  blockquote {
    border: 1px solid #999;
    padding-right: 1em;
    page-break-inside: avoid;
  }

  tr,
  img {
    page-break-inside: avoid;
  }

  img {
    max-width: 100% !important;
  }

  @page :left {
    margin: 15mm 20mm 15mm 10mm;
  }

  @page :right {
    margin: 15mm 10mm 15mm 20mm;
  }

  p,
  h2,
  h3 {
    orphans: 3;
    widows: 3;
  }

  h2,
  h3 {
    page-break-after: avoid;
  }
}


pre code.hljs{display:block;overflow-x:auto;padding:1em}code.hljs{padding:3px 5px; font-size: 12px;}/*!
  Theme: StackOverflow Light
  Description: Light theme as used on stackoverflow.com
  Author: stackoverflow.com
  Maintainer: @Hirse
  Website: https://github.com/StackExchange/Stacks
  License: MIT
  Updated: 2021-05-15

  Updated for @stackoverflow/stacks v0.64.0
  Code Blocks: /blob/v0.64.0/lib/css/components/_stacks-code-blocks.less
  Colors: /blob/v0.64.0/lib/css/exports/_stacks-constants-colors.less
*/.hljs{color:#2f3337;background:#f6f6f6}.hljs-subst{color:#2f3337}.hljs-comment{color:#656e77}.hljs-attr,.hljs-doctag,.hljs-keyword,.hljs-meta .hljs-keyword,.hljs-section,.hljs-selector-tag{color:#015692}.hljs-attribute{color:#803378}.hljs-name,.hljs-number,.hljs-quote,.hljs-selector-id,.hljs-template-tag,.hljs-type{color:#b75501}.hljs-selector-class{color:#015692}.hljs-link,.hljs-regexp,.hljs-selector-attr,.hljs-string,.hljs-symbol,.hljs-template-variable,.hljs-variable{color:#54790d}.hljs-meta,.hljs-selector-pseudo{color:#015692}.hljs-built_in,.hljs-literal,.hljs-title{color:#b75501}.hljs-bullet,.hljs-code{color:#535a60}.hljs-meta .hljs-string{color:#54790d}.hljs-deletion{color:#c02d2e}.hljs-addition{color:#2f6f44}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}

    nav {
      display: flex;
      justify-content: space-between;
      align-items: left;
      padding: 10px;
    }
    
    .nav-right {
      display: flex;
      gap: 50px;
      align-items: center;
    }
  </style>
</head>
<body>
  <nav>
    <a id="parentContentLink" href='/?context=a830b7ce-80f5-47'>Prompt again</a>

      <select id="childSubjects">
        <option value="home">Home</option>
        <!-- Children are added here onload with setChildSubjects -->
      </select>
      <!-- Add a previous and next button for prior requests? -->
      <!-- Add a button to save the current page as a markdown file -->

      
      <button id="saveButton" onclick="saveButton()">Save html</button>


  </nav>

  <div id="content">  
    <div id="parentContent">
        <p>To add LaTeX parsing to your unified pipeline, you'll need to integrate several plugins that handle the conversion of LaTeX expressions into a format that can be rendered, such as HTML with KaTeX. Here's a step-by-step guide on how to do this:</p>
<h3>Step 1: Install Necessary Packages</h3>
<p>First, ensure you have the required packages installed. You'll need <code>unified</code>, <code>remark-parse</code>, <code>remark-math</code>, <code>remark-rehype</code>, <code>rehype-katex</code>, and <code>rehype-stringify</code>. Install them using npm:</p>
<pre><code class="hljs language-bash">npm install unified remark-parse remark-math remark-rehype rehype-katex rehype-stringify</code></pre>
<h3>Step 2: Set Up the Unified Pipeline</h3>
<p>Create a script that sets up the unified pipeline with the necessary plugins to parse LaTeX:</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> unified = <span class="hljs-built_in">require</span>(<span class="hljs-string">'unified'</span>);
<span class="hljs-keyword">const</span> remarkParse = <span class="hljs-built_in">require</span>(<span class="hljs-string">'remark-parse'</span>);
<span class="hljs-keyword">const</span> remarkMath = <span class="hljs-built_in">require</span>(<span class="hljs-string">'remark-math'</span>);
<span class="hljs-keyword">const</span> remarkRehype = <span class="hljs-built_in">require</span>(<span class="hljs-string">'remark-rehype'</span>);
<span class="hljs-keyword">const</span> rehypeKatex = <span class="hljs-built_in">require</span>(<span class="hljs-string">'rehype-katex'</span>);
<span class="hljs-keyword">const</span> rehypeStringify = <span class="hljs-built_in">require</span>(<span class="hljs-string">'rehype-stringify'</span>);

<span class="hljs-keyword">const</span> <span class="hljs-title function_">processMarkdown</span> = (<span class="hljs-params">markdownContent</span>) => {
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">unified</span>()
    .<span class="hljs-title function_">use</span>(remarkParse)
    .<span class="hljs-title function_">use</span>(remarkMath)
    .<span class="hljs-title function_">use</span>(remarkRehype)
    .<span class="hljs-title function_">use</span>(rehypeKatex, { <span class="hljs-attr">throwOnError</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">errorColor</span>: <span class="hljs-string">'#cc0000'</span> })
    .<span class="hljs-title function_">use</span>(rehypeStringify)
    .<span class="hljs-title function_">processSync</span>(markdownContent)
    .<span class="hljs-title function_">toString</span>();
};

<span class="hljs-comment">// Example usage</span>
<span class="hljs-keyword">const</span> markdownWithLatex = <span class="hljs-string">`
# Heading

Inline math: $a^2 + b^2 = c^2$

Block math:
$
\\int_a^b f(x) \\, dx
$
`</span>;

<span class="hljs-keyword">const</span> htmlOutput = <span class="hljs-title function_">processMarkdown</span>(markdownWithLatex);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(htmlOutput);</code></pre>
<h3>Step 3: Customize LaTeX Rendering</h3>
<p>You can customize the rendering of LaTeX by adjusting the options passed to <code>rehype-katex</code>. For example, you can change the error color or decide whether to throw errors:</p>
<pre><code class="hljs language-javascript">.<span class="hljs-title function_">use</span>(rehypeKatex, { <span class="hljs-attr">throwOnError</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">errorColor</span>: <span class="hljs-string">'#ff0000'</span> })</code></pre>
<h3>Step 4: Testing and Validation</h3>
<p>Test your pipeline with various LaTeX expressions to ensure they are rendered correctly. You can also validate the output HTML to ensure it meets your project's requirements.</p>
<h3>Step 5: Integration with Your Project</h3>
<p>Depending on your project type (e.g., static site generator, custom scripts, documentation tools), integrate the pipeline into your build or processing workflow. Here's an example of how to integrate it into a static site generator like Gatsby:</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// gatsby-config.js</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">plugins</span>: [
    {
      <span class="hljs-attr">resolve</span>: <span class="hljs-string">'gatsby-transformer-remark'</span>,
      <span class="hljs-attr">options</span>: {
        <span class="hljs-attr">plugins</span>: [
          {
            <span class="hljs-attr">resolve</span>: <span class="hljs-string">'gatsby-remark-custom-plugin'</span>,
            <span class="hljs-attr">options</span>: {
              <span class="hljs-comment">// Your unified pipeline configuration here</span>
              <span class="hljs-attr">processors</span>: [
                <span class="hljs-built_in">require</span>(<span class="hljs-string">'remark-parse'</span>),
                <span class="hljs-built_in">require</span>(<span class="hljs-string">'remark-math'</span>),
                <span class="hljs-built_in">require</span>(<span class="hljs-string">'remark-rehype'</span>),
                <span class="hljs-built_in">require</span>(<span class="hljs-string">'rehype-katex'</span>, { <span class="hljs-attr">throwOnError</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">errorColor</span>: <span class="hljs-string">'#cc0000'</span> }),
                <span class="hljs-built_in">require</span>(<span class="hljs-string">'rehype-stringify'</span>),
              ],
            },
          },
        ],
      },
    },
  ],
};</code></pre>
<h3>Step 6: Documentation and Configuration</h3>
<p>Document how to set up and use the LaTeX parsing pipeline in your project. Include setup instructions, usage examples, customization options, and a troubleshooting guide.</p>
<p>By following these steps, you can successfully add LaTeX parsing to your unified pipeline, enhancing your project's ability to render mathematical expressions in Markdown files.</p>
    </div>
    <div id="childDivs">
      <div title="Install Necessary Packages" id="childContent1" onclick="setVisibileChild('childContent1')" hidden=true></div><div title="Set Up Unified Pipeline" id="childContent2" onclick="setVisibileChild('childContent2')" hidden=true><p>// Define the processing function
const processMarkdown = (markdownContent) => {
// Create a unified processor
const processor = unified()
.use(remarkParse) // Parse Markdown into an MDAST (Markdown Abstract Syntax Tree)
.use(remarkMath)  // Identify and parse LaTeX math expressions
.use(remarkRehype) // Convert MDAST to HAST (HTML Abstract Syntax Tree)
.use(rehypeKatex, { throwOnError: false, errorColor: '#cc0000' }) // Render LaTeX expressions using KaTeX
.use(rehypeStringify); // Convert HAST back to HTML string</p>
<p>// Process the Markdown content synchronously
const result = processor.processSync(markdownContent);</p>
<p>// Convert the result to a string
return result.toString();
};</p>
<p>// Example usage
const markdownWithLatex = `</p>
<h1>Heading</h1>
<p>Inline math: $a^2 + b^2 = c^2$</p>
<p>Block math:
$
\int_a^b f(x) \, dx
$
`;</p>
<p>const htmlOutput = processMarkdown(markdownWithLatex);
console.log(htmlOutput);</p></div><div title="Customize LaTeX Rendering" id="childContent3" onclick="setVisibileChild('childContent3')" hidden=true></div><div title="Testing and Validation" id="childContent4" onclick="setVisibileChild('childContent4')" hidden=true><p>## Inline Math
Inline math should render correctly: $a^2 + b^2 = c^2$, $\frac{x}{y}$.</p>
<p>## Block Math
Block math should also render correctly:
$
\int_a^b f(x) , dx
$</p>
<h2>Edge Cases</h2>
<p>Nested fractions: $\frac{\frac{a}{b}}{\frac{c}{d}}$.
Matrices:
$
\begin{pmatrix}
1 &#x26; 2 \
3 &#x26; 4
\end{pmatrix}
$</p>
<h2>Error Cases</h2>
<p>Invalid expressions should be handled gracefully:
$
\int_a^b f(x) , dx
$</p>
<p>const processMarkdown = (markdownContent) => {
return unified()
.use(remarkParse)
.use(remarkMath)
.use(remarkRehype)
.use(rehypeKatex, { throwOnError: false, errorColor: '#cc0000' })
.use(rehypeStringify)
.processSync(markdownContent)
.toString();
};</p>
<p>const testCases = [
{ input: '# Inline Math
Inline math: $a^2 + b^2 = c^2
    </div>
  </div>

    <script>
        function saveButton() {
          const content = document.documentElement.outerHTML; // Get the entire HTML content
          const blob = new Blob([content], { type: 'text/html' }); // Create a Blob from the content
          const url = URL.createObjectURL(blob); // Create a URL for the Blob
          const divInnerText = document.getElementById('content').innerText;
          let filename = divInnerText.substring(0, 25);
          const a = document.createElement('a'); // Create an anchor element
          a.href = url; // Set the href to the Blob URL
          
        a.download =  filename + '.html'; // Set the download attribute with a filename
          document.body.appendChild(a); // Append the anchor to the body
          a.click(); // Programmatically click the anchor to trigger the download
          document.body.removeChild(a); // Remove the anchor from the document
          URL.revokeObjectURL(url); // Release the Blob URL
        }
    </script>

    <script>
      function setChildSubjects(){
        let dropDownOptions = [];
        let childSubjects = document.getElementById('childDivs');
        for (let child of childSubjects.children){
           let subject = child.title;
           let optionValue = child.id;

           dropDownOptions.push({subject: subject, value: optionValue});
        
        }

        for (let option of dropDownOptions){
          let optionElement = document.createElement('option');
          optionElement.value = option.value;
          optionElement.text = option.subject;
          document.getElementById('childSubjects').appendChild(optionElement);
        }

        document.getElementById('childSubjects').addEventListener('change', function() {
          if(this.value == "home"){
            goHomePage();
          }else{
            setVisibleChild(this.value);
          }

          }
        );
      }
    </script>


    <script>
      function setVisibleChild(id){
        //quick flicker home to reset state, this allows hoping between child views
     
    
           let topNode = document.getElementById('content');
           let parentNode = document.getElementById('parentContent');
           let childVisibleNode = document.getElementById(id);
           let childDivs = document.getElementById('childDivs');
           for (let child of childDivs.children){
            if(child.id != id){
              child.hidden = true;
            }else{
              child.hidden = false; //redudant
            }
           }
           parentNode.hidden = true;
           childVisibleNode.hidden = false;
         }
      
    </script>

    <script>
      function goHomePage(){
         let topNode = document.getElementById('content');
         let parentNode = document.getElementById('parentContent');
         let children = document.getElementById('childDivs');
         for (let child of children.children){
            child.hidden = true;
         }
         parentNode.hidden = false;
      }
    </script>

    <script>
      function setChildLinks(){
        let children = document.getElementById('childDivs'); 
        let childSubjects = [];
        let discoveredMatches = [];

        
        for (let child of children.children){
          let subject = child.title;
          childSubjects.push({subject: subject, child: child});
          }
             
          let parentNodeH2Subjects = []
          let parentNodeH3Subjects = []
          let parentNodeH4Subjects = []
          let parentNode = document.getElementById('parentContent');
          let H2s = parentNode.getElementsByTagName("H2");
          let H3s = parentNode.getElementsByTagName("H3");
          let H4s = parentNode.getElementsByTagName("H4");
          let isH2Match = false;
          let isH3Match = false;
          let isH4Match = false;

          H2s.length > 0? parentNodeH2Subjects = H2s.map(item => ({subject: item.innerText, item: item})):isH2Match = false;
          H3s.length > 0?parentNodeH3Subjects = H3s.map(item => ({subject: item.innerText, item: item})):isH3Match = false;
          H4s.length > 0?parentNodeH4Subjects = H4s.map(item => ({subject: item.innerText, item: item})):isH4Match = false;

          
           isH3Match = H3s.length == childSubjects.length;
           isH2Match = H2s.length == childSubjects.length;
           isH4Match = H4s.length == childSubjects.length;
          let allDiscovered = false;

          if (isH3Match){
            //We have a match.  We need to find the H2s
            allDiscovered = true;
          }
          if (isH2Match){
            //We have a match.  We need to find the H3s
            allDiscovered = true;
          }
          if (isH4Match){
            //We have a match.  We need to find the H2s
            allDiscovered = true;
          }

          if(allDiscovered && (isH3Match + isH2Match + isH4Match) > 1){
            //wierd.  ok we work from scratch.
            allDiscovered = false;
          }

          if(!allDiscovered){

            let fluffWords = ["a", "an", "the", "and", "but", "or", "for", "nor", "on", "at", "to", "from", "by", "with", "of"];
            let fluffWordsRegex = new RegExp(fluffWords.join("|"), "g");
          
          //OK time to stumble through unpredictable llm output
          //First check if the child subjects are in the parent node h2 subjects
          let isH2 = false;
          let isH3 = false;
          let isH4 = false;
      
          //This can be optimized later.  Probably doesnt matter since it is client side with modern computing.
          for (let i = 0; i < parentNodeH2Subjects.length; i++){
            let subject = parentNodeH2Subjects[i].subject;
            for (let j = 0; j < childSubjects.length; j++){
              let childSubject = childSubjects[j].subject;
              if(childSubject.replace(fluffWordsRegex, "") == subject.replace(fluffWordsRegex, "")){
                isH2 = true;
                discoveredMatches.push({parentLink: parentNodeH2Subjects[i].item, childLink: childSubjects[j].child});
              }
            }

          }
         
          if(!isH2){
            for (let i = 0; i < parentNodeH3Subjects.length; i++){
              let subject = parentNodeH3Subjects[i].subject;
              for (let j = 0; j < childSubjects.length; j++){
                let childSubject = childSubjects[j].subject;  
                if(childSubject.replace(fluffWordsRegex, "") == subject.replace(fluffWordsRegex, "")){
                  isH3 = true;
                  discoveredMatches.push({parentLink: parentNodeH3Subjects[i].item, childLink: childSubjects[j].child});
                }
              }
            }
          }

          if(!isH3){
            for (let i = 0; i < parentNodeH4Subjects.length; i++){
              let subject = parentNodeH4Subjects[i].subject;
              for (let j = 0; j < childSubjects.length; j++){
                let childSubject = childSubjects[j].subject;
                if(childSubject.replace(fluffWordsRegex, "") == subject.replace(fluffWordsRegex, "")){
                  isH4 = true;
                  discoveredMatches.push({parentLink: parentNodeH4Subjects[i].item, childLink: childSubjects[j].child});
                }
              }
            }
          }

          if(!isH4){
              //I suppose there are edge cases but this surely covers 99.9% of the cases.
          }

          }else{
            if(isH3Match){
              for (let i = 0; i < parentNodeH3Subjects.length; i++){
                let child = childSubjects[i].child;
                makeChildLinks(parentNodeH3Subjects[i].item, child);
              }
              return; //bye bye
            }
            if(isH2Match){
              for (let i = 0; i < parentNodeH2Subjects.length; i++){
                let child = childSubjects[i].child;
                makeChildLinks(parentNodeH2Subjects[i].item, child);
                return; //bye bye
              }
              if(isH4Match){
                for (let i = 0; i < parentNodeH4Subjects.length; i++){
                  let child = childSubjects[i].child;
                  makeChildLinks(parentNodeH4Subjects[i].item, child);
                }
              }

            }

          }

          for (let match of discoveredMatches){
            makeChildLinks(match.parentLink, match.childLink);
            if(match.length < childSubjects.length){ alert("LLMM added additional info that is hidden");}
          }

        }
    </script>

    <script>
       function makeChildLinks(parent, child){
            parent.style.cursor = "pointer";
            parent.style.textDecoration = "underline";
            parent.style.color = "blue";
            parent.onclick = function(){
              setVisibleChild(child.id);
            }
       }

    </script>

<script>window.onload = setChildSubjects;</script>

</body>
</html>


   
    <!-- <textarea id="userPrompt"></textarea>

    <script>
        function nextButton() {
            const userPrompt = document.getElementById('userPrompt').value;
            console.log(userPrompt);
        }
    </script> -->, expected: '&#x3C;h1>Inline Math&#x3C;/h1>&#x3C;p>Inline math: &#x3C;span class="katex">&#x3C;math xmlns="http://www.w3.org/1998/Math/MathML">&#x3C;semantics>&#x3C;mrow>&#x3C;msup>&#x3C;mi>a&#x3C;/mi>&#x3C;mn>2&#x3C;/mn>&#x3C;/msup>&#x3C;mo>+&#x3C;/mo>&#x3C;msup>&#x3C;mi>b&#x3C;/mi>&#x3C;mn>2&#x3C;/mn>&#x3C;/msup>&#x3C;mo>=&#x3C;/mo>&#x3C;msup>&#x3C;mi>c&#x3C;/mi>&#x3C;mn>2&#x3C;/mn>&#x3C;/msup>&#x3C;/mrow>&#x3C;annotation encoding="application/x-tex">a^2 + b^2 = c^2&#x3C;/annotation>&#x3C;/semantics>&#x3C;/math>&#x3C;/span>&#x3C;/p>' },
{ input: '# Block Math
$
\int_a^b f(x) \, dx
$', expected: '&#x3C;h1>Block Math&#x3C;/h1>&#x3C;p>&#x3C;span class="katex-display">&#x3C;math xmlns="http://www.w3.org/1998/Math/MathML" display="block">&#x3C;semantics>&#x3C;mrow>&#x3C;mo>∫&#x3C;/mo>&#x3C;msubsup>&#x3C;mo data-mjx-texclass="OP">∬&#x3C;/mo>&#x3C;mi>a&#x3C;/mi>&#x3C;mi>b&#x3C;/mi>&#x3C;/msubsup>&#x3C;mi>f&#x3C;/mi>&#x3C;mo stretchy="false">(&#x3C;/mo>&#x3C;mi>x&#x3C;/mi>&#x3C;mo stretchy="false">)&#x3C;/mo>&#x3C;mtext> &#x3C;/mtext>&#x3C;mi>d&#x3C;/mi>&#x3C;mi>x&#x3C;/mi>&#x3C;/mrow>&#x3C;annotation encoding="application/x-tex">
\int_a^b f(x) , dx
&#x3C;/annotation>&#x3C;/semantics>&#x3C;/math>&#x3C;/span>&#x3C;/p>' },
];</p>
<p>testCases.forEach(testCase => {
const output = processMarkdown(testCase.input);
if (output.includes(testCase.expected)) {
console.log(<code>Test passed for: &#x3C;span class="hljs-subst">${testCase.input}&#x3C;/span></code>);
} else {
console.error(<code>Test failed for: &#x3C;span class="hljs-subst">${testCase.input}&#x3C;/span></code>);
console.error(<code>Expected: &#x3C;span class="hljs-subst">${testCase.expected}&#x3C;/span></code>);
console.error(<code>Got: &#x3C;span class="hljs-subst">${output}&#x3C;/span></code>);
}
});</p></div><div title="Integration with Your Project" id="childContent5" onclick="setVisibileChild('childContent5')" hidden=true><p>const processMarkdownFile = (inputPath, outputPath) => {
const markdownContent = fs.readFileSync(inputPath, 'utf8');
const htmlOutput = unified()
.use(remarkParse)
.use(remarkMath)
.use(remarkRehype)
.use(rehypeKatex, { throwOnError: false, errorColor: '#cc0000' })
.use(rehypeStringify)
.processSync(markdownContent)
.toString();</p>
<p>fs.writeFileSync(outputPath, htmlOutput);
};</p>
<p>// Example usage
const inputFile = path.join(__dirname, 'input.md');
const outputFile = path.join(__dirname, 'output.html');
processMarkdownFile(inputFile, outputFile);</p></div><div title="Documentation and Configuration" id="childContent6" onclick="setVisibileChild('childContent6')" hidden=true><p>const processMarkdown = (markdownContent) => {
return unified()
.use(remarkParse)
.use(remarkMath)
.use(remarkRehype)
.use(rehypeKatex, { throwOnError: false, errorColor: '#cc0000' })
.use(rehypeStringify)
.processSync(markdownContent)
.toString();
};</p>
<p>Inline math: $a^2 + b^2 = c^2$</p>
<p>Block math:
$
\int_a^b f(x) , dx
$</p></div>
    </div>
  </div>

    <script>
        function saveButton() {
          const content = document.documentElement.outerHTML; // Get the entire HTML content
          const blob = new Blob([content], { type: 'text/html' }); // Create a Blob from the content
          const url = URL.createObjectURL(blob); // Create a URL for the Blob
          const divInnerText = document.getElementById('content').innerText;
          let filename = divInnerText.substring(0, 25);
          const a = document.createElement('a'); // Create an anchor element
          a.href = url; // Set the href to the Blob URL
          
        a.download =  filename + '.html'; // Set the download attribute with a filename
          document.body.appendChild(a); // Append the anchor to the body
          a.click(); // Programmatically click the anchor to trigger the download
          document.body.removeChild(a); // Remove the anchor from the document
          URL.revokeObjectURL(url); // Release the Blob URL
        }
    </script>

    <script>
      function setChildSubjects(){
        let dropDownOptions = [];
        let childSubjects = document.getElementById('childDivs');
        for (let child of childSubjects.children){
           let subject = child.title;
           let optionValue = child.id;

           dropDownOptions.push({subject: subject, value: optionValue});
        
        }

        for (let option of dropDownOptions){
          let optionElement = document.createElement('option');
          optionElement.value = option.value;
          optionElement.text = option.subject;
          document.getElementById('childSubjects').appendChild(optionElement);
        }

        document.getElementById('childSubjects').addEventListener('change', function() {
          if(this.value == "home"){
            goHomePage();
          }else{
            setVisibleChild(this.value);
          }

          }
        );
      }
    </script>


    <script>
      function setVisibleChild(id){
        //quick flicker home to reset state, this allows hoping between child views
     
    
           let topNode = document.getElementById('content');
           let parentNode = document.getElementById('parentContent');
           let childVisibleNode = document.getElementById(id);
           let childDivs = document.getElementById('childDivs');
           for (let child of childDivs.children){
            if(child.id != id){
              child.hidden = true;
            }else{
              child.hidden = false; //redudant
            }
           }
           parentNode.hidden = true;
           childVisibleNode.hidden = false;
         }
      
    </script>

    <script>
      function goHomePage(){
         let topNode = document.getElementById('content');
         let parentNode = document.getElementById('parentContent');
         let children = document.getElementById('childDivs');
         for (let child of children.children){
            child.hidden = true;
         }
         parentNode.hidden = false;
      }
    </script>

    <script>
      function setChildLinks(){
        let children = document.getElementById('childDivs'); 
        let childSubjects = [];
        let discoveredMatches = [];

        
        for (let child of children.children){
          let subject = child.title;
          childSubjects.push({subject: subject, child: child});
          }
             
          let parentNodeH2Subjects = []
          let parentNodeH3Subjects = []
          let parentNodeH4Subjects = []
          let parentNode = document.getElementById('parentContent');
          let H2s = parentNode.getElementsByTagName("H2");
          let H3s = parentNode.getElementsByTagName("H3");
          let H4s = parentNode.getElementsByTagName("H4");
          let isH2Match = false;
          let isH3Match = false;
          let isH4Match = false;

          H2s.length > 0? parentNodeH2Subjects = H2s.map(item => ({subject: item.innerText, item: item})):isH2Match = false;
          H3s.length > 0?parentNodeH3Subjects = H3s.map(item => ({subject: item.innerText, item: item})):isH3Match = false;
          H4s.length > 0?parentNodeH4Subjects = H4s.map(item => ({subject: item.innerText, item: item})):isH4Match = false;

          
           isH3Match = H3s.length == childSubjects.length;
           isH2Match = H2s.length == childSubjects.length;
           isH4Match = H4s.length == childSubjects.length;
          let allDiscovered = false;

          if (isH3Match){
            //We have a match.  We need to find the H2s
            allDiscovered = true;
          }
          if (isH2Match){
            //We have a match.  We need to find the H3s
            allDiscovered = true;
          }
          if (isH4Match){
            //We have a match.  We need to find the H2s
            allDiscovered = true;
          }

          if(allDiscovered && (isH3Match + isH2Match + isH4Match) > 1){
            //wierd.  ok we work from scratch.
            allDiscovered = false;
          }

          if(!allDiscovered){

            let fluffWords = ["a", "an", "the", "and", "but", "or", "for", "nor", "on", "at", "to", "from", "by", "with", "of"];
            let fluffWordsRegex = new RegExp(fluffWords.join("|"), "g");
          
          //OK time to stumble through unpredictable llm output
          //First check if the child subjects are in the parent node h2 subjects
          let isH2 = false;
          let isH3 = false;
          let isH4 = false;
      
          //This can be optimized later.  Probably doesnt matter since it is client side with modern computing.
          for (let i = 0; i < parentNodeH2Subjects.length; i++){
            let subject = parentNodeH2Subjects[i].subject;
            for (let j = 0; j < childSubjects.length; j++){
              let childSubject = childSubjects[j].subject;
              if(childSubject.replace(fluffWordsRegex, "") == subject.replace(fluffWordsRegex, "")){
                isH2 = true;
                discoveredMatches.push({parentLink: parentNodeH2Subjects[i].item, childLink: childSubjects[j].child});
              }
            }

          }
         
          if(!isH2){
            for (let i = 0; i < parentNodeH3Subjects.length; i++){
              let subject = parentNodeH3Subjects[i].subject;
              for (let j = 0; j < childSubjects.length; j++){
                let childSubject = childSubjects[j].subject;  
                if(childSubject.replace(fluffWordsRegex, "") == subject.replace(fluffWordsRegex, "")){
                  isH3 = true;
                  discoveredMatches.push({parentLink: parentNodeH3Subjects[i].item, childLink: childSubjects[j].child});
                }
              }
            }
          }

          if(!isH3){
            for (let i = 0; i < parentNodeH4Subjects.length; i++){
              let subject = parentNodeH4Subjects[i].subject;
              for (let j = 0; j < childSubjects.length; j++){
                let childSubject = childSubjects[j].subject;
                if(childSubject.replace(fluffWordsRegex, "") == subject.replace(fluffWordsRegex, "")){
                  isH4 = true;
                  discoveredMatches.push({parentLink: parentNodeH4Subjects[i].item, childLink: childSubjects[j].child});
                }
              }
            }
          }

          if(!isH4){
              //I suppose there are edge cases but this surely covers 99.9% of the cases.
          }

          }else{
            if(isH3Match){
              for (let i = 0; i < parentNodeH3Subjects.length; i++){
                let child = childSubjects[i].child;
                makeChildLinks(parentNodeH3Subjects[i].item, child);
              }
              return; //bye bye
            }
            if(isH2Match){
              for (let i = 0; i < parentNodeH2Subjects.length; i++){
                let child = childSubjects[i].child;
                makeChildLinks(parentNodeH2Subjects[i].item, child);
                return; //bye bye
              }
              if(isH4Match){
                for (let i = 0; i < parentNodeH4Subjects.length; i++){
                  let child = childSubjects[i].child;
                  makeChildLinks(parentNodeH4Subjects[i].item, child);
                }
              }

            }

          }

          for (let match of discoveredMatches){
            makeChildLinks(match.parentLink, match.childLink);
            if(match.length < childSubjects.length){ alert("LLMM added additional info that is hidden");}
          }

        }
    </script>

    <script>
       function makeChildLinks(parent, child){
            parent.style.cursor = "pointer";
            parent.style.textDecoration = "underline";
            parent.style.color = "blue";
            parent.onclick = function(){
              setVisibleChild(child.id);
            }
       }

    </script>

<script>window.onload = setChildSubjects;</script>

</body>
</html>


   
    <!-- <textarea id="userPrompt"></textarea>

    <script>
        function nextButton() {
            const userPrompt = document.getElementById('userPrompt').value;
            console.log(userPrompt);
        }
    </script> -->