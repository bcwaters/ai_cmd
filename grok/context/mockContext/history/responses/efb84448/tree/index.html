<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Home Page</title>
</head>
<body>
  <nav>
    <button id="saveButton" onclick="saveButton()">Save html</button>
    <a id="parentContentLink" href='javascript:goHomePage()'>Home</a>
    <select id="childSubjects">
      <option value="home">Home</option>
      <!-- Children are added here onload with setChildSubjects -->
    </select>
    <!-- Add a previous and next button for prior requests? -->
    <!-- Add a button to save the current page as a markdown file -->
  </nav>

  <div id="content">  
    <div id="parentContent">
        <h1>Testing One Two Three</h1>
<p>It looks like you're testing the system. I understand and am ready to assist you further.</p>
<h3>Follow-up Questions:</h3>
<ul>
<li>Is there a specific feature or functionality you are testing?</li>
<li>Do you have any questions about how the system works?</li>
<li>Would you like to proceed with a particular topic or task?</li>
</ul>

    </div>
    <div id="childDivs">
      <div title="TestingOne Two Three" id="childContent1" onclick="setVisibileChild('childContent1')" hidden=true><h1>Understanding the Instructions</h1>
<p>In response to your query about item 1 of the list "TestingOne Two Three," here is a detailed explanation:</p>
<p><strong>TestingOne</strong> refers to the first item in the list you provided. This term might be used in a context where a sequence or a test is being conducted, emphasizing the initial step or component. The inclusion of "One" suggests it is the first in a series, possibly indicating a methodical approach to testing or enumeration.</p>
<p>Given that this is the first mention of "TestingOne," there's no previous information to expand upon directly. However, if "TestingOne" is part of a larger testing protocol or checklist, it could represent the initiation of such a process, ensuring that the first step is correctly acknowledged and executed.</p>
<h3>Follow-up Questions:</h3>
<ul>
<li>Can you provide more context about the "TestingOne Two Three" list? What is its purpose?</li>
<li>Are there specific criteria or outcomes associated with "TestingOne" that you're looking to understand?</li>
<li>Is "TestingOne" part of a standardized testing procedure in your field or industry?</li>
</ul>
<p>ResponseID:cb75644f</p>
</div><div title="SystemFeatures" id="childContent2" onclick="setVisibileChild('childContent2')" hidden=true><h1>System Features</h1>
<p>In the context of software or technology, <strong>System Features</strong> refer to the specific functionalities or capabilities that a system offers to its users. These features are designed to enhance user experience, improve efficiency, and provide solutions to specific problems or needs. Here are some aspects that might be included under System Features:</p>
<ul>
<li><p><strong>User Interface (UI)</strong>: This includes the design elements that users interact with. A well-designed UI can significantly improve the usability of a system, making it more intuitive and user-friendly.</p>
</li>
<li><p><strong>Performance</strong>: This refers to how quickly and efficiently the system can process tasks. High performance is crucial for systems that handle large amounts of data or require real-time processing.</p>
</li>
<li><p><strong>Security</strong>: Features that protect the system and its data from unauthorized access or attacks. This might include encryption, firewalls, and user authentication methods.</p>
</li>
<li><p><strong>Scalability</strong>: The ability of the system to handle growth, whether it's an increase in data volume, user base, or transaction volume, without compromising performance.</p>
</li>
<li><p><strong>Integration Capabilities</strong>: How well the system can connect and work with other systems or software. Good integration can enhance functionality and streamline workflows.</p>
</li>
<li><p><strong>Customization</strong>: Options for users to tailor the system to their specific needs or preferences. This might include configurable settings or the ability to add custom modules.</p>
</li>
<li><p><strong>Support and Maintenance</strong>: Features that facilitate updates, troubleshooting, and maintenance of the system. This could include automated updates, diagnostic tools, or a help center.</p>
</li>
</ul>
<p>Understanding these aspects of System Features can help in evaluating or designing systems that meet specific user requirements and business goals.</p>
<h3>Follow-up Questions:</h3>
<ul>
<li>Can you describe a specific system feature that you find particularly useful or innovative?</li>
<li>How do system features impact the overall user experience in software you use?</li>
<li>Are there any system features you think are commonly overlooked but are crucial for certain applications?</li>
</ul>
<p>ResponseID:fd0e4a86</p>
</div><div title="HowSystem Works" id="childContent3" onclick="setVisibileChild('childContent3')" hidden=true><h1>How the System Works</h1>
<p>The system operates based on a set of predefined instructions to ensure efficient and accurate responses to user queries. Here's a detailed breakdown of how it functions:</p>
<ul>
<li><p><strong>Input Processing</strong>: When a user submits a query, the system first processes the input to understand the context and requirements. This involves parsing the text to identify key elements such as the main topic, any specific questions, and the format requested.</p>
</li>
<li><p><strong>Contextual Understanding</strong>: The system uses the provided context to tailor the response. In the case of the initial query, it was noted that this was the beginning of the conversation, which influences how the system generates the response without prior history.</p>
</li>
<li><p><strong>Response Generation</strong>: The response is crafted in Markdown format as per the user's request. The system ensures that the response adheres to the specified format, including headings, lists, and any other Markdown elements.</p>
</li>
<li><p><strong>Follow-up Suggestions</strong>: After the main response, the system suggests follow-up questions to keep the conversation flowing and to help the user explore related topics.</p>
</li>
<li><p><strong>Delimiter and Keywords</strong>: The system includes an `</p>
</li>
</ul>
<p>ResponseID:fae9cb87</p>
</div><div title="Proceedwith Topic" id="childContent4" onclick="setVisibileChild('childContent4')" hidden=true><h1>Item 4: Proceed with Topic</h1>
<p>Given that the context of this conversation is at its beginning and no prior list was provided, it's challenging to delve into specifics about "item 4" from a non-existent list. However, I can provide a general approach on how to proceed with a topic in a conversation or discussion setting:</p>
<h3>How to Proceed with a Topic</h3>
<ul>
<li><strong>Clarify the Topic</strong>: Ensure that the topic is clearly understood by all parties. Ask for clarification if needed.</li>
<li><strong>Gather Information</strong>: Research or brainstorm to gather more information on the topic. This can involve looking at different perspectives or data.</li>
<li><strong>Engage in Discussion</strong>: Start discussing the topic, allowing for open exchange of ideas. Encourage questions and diverse viewpoints.</li>
<li><strong>Summarize and Plan Next Steps</strong>: After a thorough discussion, summarize key points and decide on the next steps or actions.</li>
</ul>
<p>If you were referring to a specific list or context not mentioned here, please provide more details, and I'll be happy to elaborate further.</p>
<h3>Follow-up Questions</h3>
<ul>
<li>Do you have a specific topic in mind that you want to discuss?</li>
<li>Are there any particular aspects of proceeding with a topic that you find challenging?</li>
<li>Would you like to see an example of how to proceed with a topic in a professional setting?</li>
</ul>
<p>ResponseID:c10f137f</p>
</div>
    </div>
  </div>

    <script>
        function saveButton() {
          const content = document.documentElement.outerHTML; // Get the entire HTML content
          const blob = new Blob([content], { type: 'text/html' }); // Create a Blob from the content
          const url = URL.createObjectURL(blob); // Create a URL for the Blob
          const divInnerText = document.getElementById('content').innerText;
          let filename = divInnerText.substring(0, 25);
          const a = document.createElement('a'); // Create an anchor element
          a.href = url; // Set the href to the Blob URL
          
        a.download =  filename + '.html'; // Set the download attribute with a filename
          document.body.appendChild(a); // Append the anchor to the body
          a.click(); // Programmatically click the anchor to trigger the download
          document.body.removeChild(a); // Remove the anchor from the document
          URL.revokeObjectURL(url); // Release the Blob URL
        }
    </script>

    <script>
      function setChildSubjects(){
        let dropDownOptions = [];
        let childSubjects = document.getElementById('childDivs');
        for (let child of childSubjects.children){
           let subject = child.title;
           let optionValue = child.id;

           dropDownOptions.push({subject: subject, value: optionValue});
        
        }

        for (let option of dropDownOptions){
          let optionElement = document.createElement('option');
          optionElement.value = option.value;
          optionElement.text = option.subject;
          document.getElementById('childSubjects').appendChild(optionElement);
        }

        document.getElementById('childSubjects').addEventListener('change', function() {
          if(this.value == "home"){
            goHomePage();
          }else{
            setVisibleChild(this.value);
          }

          }
        );
      }
    </script>


    <script>
      function setVisibleChild(id){
        //quick flicker home to reset state, this allows hoping between child views
     
    
           let topNode = document.getElementById('content');
           let parentNode = document.getElementById('parentContent');
           let childVisibleNode = document.getElementById(id);
           let childDivs = document.getElementById('childDivs');
           for (let child of childDivs.children){
            if(child.id != id){
              child.hidden = true;
            }else{
              child.hidden = false; //redudant
            }
           }
           parentNode.hidden = true;
           childVisibleNode.hidden = false;
         }
      
    </script>

    <script>
      function goHomePage(){
         let topNode = document.getElementById('content');
         let parentNode = document.getElementById('parentContent');
         let children = document.getElementById('childDivs');
         for (let child of children.children){
            child.hidden = true;
         }
         parentNode.hidden = false;
      }
    </script>

    <script>
      function setChildLinks(){
        let children = document.getElementById('childDivs'); 
        let childSubjects = [];
        let discoveredMatches = [];

        
        for (let child of children.children){
          let subject = child.title;
          childSubjects.push({subject: subject, child: child});
          }
             
          let parentNodeH2Subjects = []
          let parentNodeH3Subjects = []
          let parentNodeH4Subjects = []
          let parentNode = document.getElementById('parentContent');
          let H2s = parentNode.getElementsByTagName("H2");
          let H3s = parentNode.getElementsByTagName("H3");
          let H4s = parentNode.getElementsByTagName("H4");
          let isH2Match = false;
          let isH3Match = false;
          let isH4Match = false;

          H2s.length > 0? parentNodeH2Subjects = H2s.map(item => ({subject: item.innerText, item: item})):isH2Match = false;
          H3s.length > 0?parentNodeH3Subjects = H3s.map(item => ({subject: item.innerText, item: item})):isH3Match = false;
          H4s.length > 0?parentNodeH4Subjects = H4s.map(item => ({subject: item.innerText, item: item})):isH4Match = false;

          
           isH3Match = H3s.length == childSubjects.length;
           isH2Match = H2s.length == childSubjects.length;
           isH4Match = H4s.length == childSubjects.length;
          let allDiscovered = false;

          if (isH3Match){
            //We have a match.  We need to find the H2s
            allDiscovered = true;
          }
          if (isH2Match){
            //We have a match.  We need to find the H3s
            allDiscovered = true;
          }
          if (isH4Match){
            //We have a match.  We need to find the H2s
            allDiscovered = true;
          }

          if(allDiscovered && (isH3Match + isH2Match + isH4Match) > 1){
            //wierd.  ok we work from scratch.
            allDiscovered = false;
          }

          if(!allDiscovered){

            let fluffWords = ["a", "an", "the", "and", "but", "or", "for", "nor", "on", "at", "to", "from", "by", "with", "of"];
            let fluffWordsRegex = new RegExp(fluffWords.join("|"), "g");
          
          //OK time to stumble through unpredictable llm output
          //First check if the child subjects are in the parent node h2 subjects
          let isH2 = false;
          let isH3 = false;
          let isH4 = false;
      
          //This can be optimized later.  Probably doesnt matter since it is client side with modern computing.
          for (let i = 0; i < parentNodeH2Subjects.length; i++){
            let subject = parentNodeH2Subjects[i].subject;
            for (let j = 0; j < childSubjects.length; j++){
              let childSubject = childSubjects[j].subject;
              if(childSubject.replace(fluffWordsRegex, "") == subject.replace(fluffWordsRegex, "")){
                isH2 = true;
                discoveredMatches.push({parentLink: parentNodeH2Subjects[i].item, childLink: childSubjects[j].child});
              }
            }

          }
         
          if(!isH2){
            for (let i = 0; i < parentNodeH3Subjects.length; i++){
              let subject = parentNodeH3Subjects[i].subject;
              for (let j = 0; j < childSubjects.length; j++){
                let childSubject = childSubjects[j].subject;  
                if(childSubject.replace(fluffWordsRegex, "") == subject.replace(fluffWordsRegex, "")){
                  isH3 = true;
                  discoveredMatches.push({parentLink: parentNodeH3Subjects[i].item, childLink: childSubjects[j].child});
                }
              }
            }
          }

          if(!isH3){
            for (let i = 0; i < parentNodeH4Subjects.length; i++){
              let subject = parentNodeH4Subjects[i].subject;
              for (let j = 0; j < childSubjects.length; j++){
                let childSubject = childSubjects[j].subject;
                if(childSubject.replace(fluffWordsRegex, "") == subject.replace(fluffWordsRegex, "")){
                  isH4 = true;
                  discoveredMatches.push({parentLink: parentNodeH4Subjects[i].item, childLink: childSubjects[j].child});
                }
              }
            }
          }

          if(!isH4){
              //I suppose there are edge cases but this surely covers 99.9% of the cases.
          }

          }else{
            if(isH3Match){
              for (let i = 0; i < parentNodeH3Subjects.length; i++){
                let child = childSubjects[i].child;
                makeChildLinks(parentNodeH3Subjects[i].item, child);
              }
              return; //bye bye
            }
            if(isH2Match){
              for (let i = 0; i < parentNodeH2Subjects.length; i++){
                let child = childSubjects[i].child;
                makeChildLinks(parentNodeH2Subjects[i].item, child);
                return; //bye bye
              }
              if(isH4Match){
                for (let i = 0; i < parentNodeH4Subjects.length; i++){
                  let child = childSubjects[i].child;
                  makeChildLinks(parentNodeH4Subjects[i].item, child);
                }
              }

            }

          }

          for (let match of discoveredMatches){
            makeChildLinks(match.parentLink, match.childLink);
            if(match.length < childSubjects.length){ alert("LLMM added additional info that is hidden");}
          }

        }
    </script>

    <script>
       function makeChildLinks(parent, child){
            parent.style.cursor = "pointer";
            parent.style.textDecoration = "underline";
            parent.style.color = "blue";
            parent.onclick = function(){
              setVisibleChild(child.id);
            }
       }

    </script>

<script>window.onload = setChildSubjects;</script>

</body>
</html>


   
    <!-- <textarea id="userPrompt"></textarea>

    <script>
        function nextButton() {
            const userPrompt = document.getElementById('userPrompt').value;
            console.log(userPrompt);
        }
    </script> -->