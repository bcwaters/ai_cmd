<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Home Page</title>
</head>
<body>
  <nav>
    <button id="saveButton" onclick="saveButton()">Save html</button>
    <a id="parentContentLink" href='javascript:goHomePage()'>Home</a>
    <select id="childSubjects">
      <option value="home">Home</option>
      <!-- Children are added here onload with setChildSubjects -->
    </select>
    <!-- Add a previous and next button for prior requests? -->
    <!-- Add a button to save the current page as a markdown file -->
  </nav>

  <div id="content">  
    <div id="parentContent">
        <h2>Jest Features</h2>
<ol>
<li><p><strong>Snapshot Testing</strong></p>
<ul>
<li>Allows you to capture the rendered output of a component and compare it to a reference snapshot file stored alongside the test. This is particularly useful for ensuring UI components don't unexpectedly change.</li>
</ul>
</li>
<li><p><strong>Mock Functions</strong></p>
<ul>
<li>Jest provides a robust way to mock functions, which is essential for isolating the code you're testing. You can use <code>jest.fn()</code> to create mock functions and track calls, arguments, and return values.</li>
</ul>
</li>
</ol>

    </div>
    <div id="childDivs">
      <div title="Snapshot Testing" id="childContent1" onclick="setVisibileChild('childContent1')" hidden=true><h2>Snapshot Testing in Jest</h2>
<p>Snapshot testing is a powerful feature in Jest that allows developers to ensure the consistency of UI components by capturing their rendered output and comparing it against a reference snapshot file. Here's an in-depth look at how snapshot testing works and its benefits:</p>
<h3>How Snapshot Testing Works</h3>
<ol>
<li><p><strong>Capturing a Snapshot:</strong></p>
<ul>
<li>When you run a test that uses snapshot testing, Jest will render the component and save its output as a snapshot file in a <code>__snapshots__</code> directory next to your test file. This snapshot file is usually a <code>.snap</code> file and contains the serialized output of your component.</li>
<li>Example of a test using snapshot testing in Jest:<pre><code class="language-javascript">import React from 'react';
import renderer from 'react-test-renderer';
import MyComponent from './MyComponent';

</code><p><code class="language-javascript">test('MyComponent renders correctly', () =&gt; {
  const tree = renderer.create(&lt;MyComponent /&gt;).toJSON();
  expect(tree).toMatchSnapshot();
});
</code></p></pre><p></p>
</li>
<li>In this example, <code>renderer.create(&lt;MyComponent /&gt;)</code> renders the component, and <code>.toJSON()</code> serializes it. The <code>expect(tree).toMatchSnapshot()</code> assertion will create a snapshot file if it doesn't exist or compare it against the existing one.</li>
</ul>
</li>
<li><p><strong>Comparing Snapshots:</strong></p>
<ul>
<li>On subsequent test runs, Jest will compare the newly generated snapshot with the stored snapshot. If they match, the test passes. If they don't match, Jest will fail the test and display a diff of the changes.</li>
<li>You can update the snapshot by running your tests with the <code>--updateSnapshot</code> or <code>-u</code> flag. This is useful when intentional changes have been made to the component.</li>
</ul>
</li>
</ol>
<h3>Benefits of Snapshot Testing</h3>
<ol>
<li><p><strong>Detecting Unintended Changes:</strong></p>
<ul>
<li>Snapshot testing excels at catching unintended changes in UI components. If a developer accidentally modifies the component in a way that affects its rendering, the snapshot test will fail, alerting the team to the change.</li>
</ul>
</li>
<li><p><strong>Efficiency in UI Testing:</strong></p>
<ul>
<li>It's often easier to write snapshot tests compared to writing detailed assertions for every aspect of a component's output. This can save time and make your test suite more maintainable.</li>
</ul>
</li>
<li><p><strong>Version Control Integration:</strong></p>
<ul>
<li>Since snapshots are stored in version control, they serve as a visual history of your UI components. This can be invaluable for understanding how your UI has evolved over time.</li>
</ul>
</li>
<li><p><strong>Customizable Snapshots:</strong></p>
<ul>
<li>You can customize what gets included in a snapshot. For instance, you might want to ignore certain dynamic data or focus on specific parts of the component's output.</li>
</ul>
</li>
</ol>
<h3>Best Practices for Snapshot Testing</h3>
<ol>
<li><p><strong>Review Snapshots:</strong></p>
<ul>
<li>Always review new or updated snapshots before committing them. This ensures that any changes to the snapshot are intentional and correct.</li>
</ul>
</li>
<li><p><strong>Use Snapshots for Stable Components:</strong></p>
<ul>
<li>Snapshot testing is most effective for components with stable, predictable output. Avoid using it for components with highly dynamic or data-driven content.</li>
</ul>
</li>
<li><p><strong>Combine with Other Testing Techniques:</strong></p>
<ul>
<li>Snapshot testing should complement, not replace, other types of tests like unit tests and integration tests. Use it as part of a comprehensive testing strategy.</li>
</ul>
</li>
<li><p><strong>Manage Snapshot Files:</strong></p>
<ul>
<li>Keep your snapshot files organized and clean. Remove unnecessary snapshots and ensure they are stored in a logical structure within your project.</li>
</ul>
</li>
</ol>
<p>By leveraging snapshot testing in Jest, developers can maintain a high level of confidence in the consistency and correctness of their UI components, making it easier to catch and fix issues before they reach production.</p>
<p>ResponseID:a2c6e16c-2464-49</p>
</div><div title="Mock Functions" id="childContent2" onclick="setVisibileChild('childContent2')" hidden=true><h2>Mock Functions in Jest</h2>
<h3>Introduction to Mock Functions</h3>
<p>Mock functions in Jest are a powerful feature used to simulate the behavior of real objects in a controlled way. This is particularly useful in unit testing, where you want to isolate the code being tested from its dependencies.</p>
<h3>Creating Mock Functions</h3>
<p>In Jest, mock functions can be created using <code>jest.fn()</code>. This function returns a new mock function that you can use in your tests. Here's how you create a basic mock function:</p>
<pre><code class="language-javascript">const mockFunction = jest.fn();
</code></pre>
<h3>Tracking Calls</h3>
<p>One of the key features of mock functions is the ability to track how they are called. You can check if the function was called, how many times it was called, and with what arguments:</p>
<pre><code class="language-javascript">mockFunction('arg1', 'arg2');
expect(mockFunction).toHaveBeenCalled();
expect(mockFunction).toHaveBeenCalledTimes(1);
expect(mockFunction).toHaveBeenCalledWith('arg1', 'arg2');
</code></pre>
<h3>Customizing Return Values</h3>
<p>Mock functions can be configured to return specific values. This is useful for simulating different scenarios in your tests:</p>
<pre><code class="language-javascript">mockFunction.mockReturnValue('mockReturnValue');
expect(mockFunction()).toBe('mockReturnValue');
</code></pre>
<p>You can also set up the mock function to return different values on successive calls:</p>
<pre><code class="language-javascript">mockFunction
  .mockReturnValueOnce('first call')
  .mockReturnValueOnce('second call')
  .mockReturnValue('default return');

</code><p><code class="language-javascript">expect(mockFunction()).toBe('first call');
expect(mockFunction()).toBe('second call');
expect(mockFunction()).toBe('default return');
</code></p></pre><p></p>
<h3>Simulating Errors</h3>
<p>You can also use mock functions to simulate errors, which is useful for testing error handling:</p>
<pre><code class="language-javascript">mockFunction.mockImplementationOnce(() =&gt; {
  throw new Error('Mock error');
});

</code><p><code class="language-javascript">expect(() =&gt; mockFunction()).toThrow('Mock error');
</code></p></pre><p></p>
<h3>Mocking Modules</h3>
<p>Jest also allows you to mock entire modules, which can be useful when testing components that depend on external libraries or other parts of your application. You can use <code>jest.mock()</code> to mock a module:</p>
<pre><code class="language-javascript">jest.mock('moduleName', () =&gt; ({
  exportedFunction: jest.fn(),
}));
</code></pre>
<h3>Advanced Usage</h3>
<p>For more complex scenarios, you can use <code>mockImplementation</code> to define the behavior of the mock function:</p>
<pre><code class="language-javascript">const mockFunction = jest.fn().mockImplementation((arg) =&gt; {
  return `Processed: ${arg}`;
});

</code><p><code class="language-javascript">expect(mockFunction('input')).toBe('Processed: input');
</code></p></pre><p></p>
<h3>Best Practices</h3>
<ul>
<li><strong>Isolation</strong>: Use mock functions to isolate the unit of code you are testing from its dependencies.</li>
<li><strong>Clarity</strong>: Ensure that your mock functions clearly represent the behavior you are testing.</li>
<li><strong>Reusability</strong>: Consider creating reusable mock functions for commonly used dependencies.</li>
</ul>
<p>By leveraging mock functions in Jest, you can create more robust and reliable tests that focus on the specific behavior of your code, making it easier to catch bugs and ensure the quality of your software.</p>
<p>ResponseID:764208a0-34e6-48</p>
</div>
    </div>
  </div>

    <script>
        function saveButton() {
          const content = document.documentElement.outerHTML; // Get the entire HTML content
          const blob = new Blob([content], { type: 'text/html' }); // Create a Blob from the content
          const url = URL.createObjectURL(blob); // Create a URL for the Blob
          const divInnerText = document.getElementById('content').innerText;
          let filename = divInnerText.substring(0, 25);
          const a = document.createElement('a'); // Create an anchor element
          a.href = url; // Set the href to the Blob URL
          
        a.download =  filename + '.html'; // Set the download attribute with a filename
          document.body.appendChild(a); // Append the anchor to the body
          a.click(); // Programmatically click the anchor to trigger the download
          document.body.removeChild(a); // Remove the anchor from the document
          URL.revokeObjectURL(url); // Release the Blob URL
        }
    </script>

    <script>
      function setChildSubjects(){
        let dropDownOptions = [];
        let childSubjects = document.getElementById('childDivs');
        for (let child of childSubjects.children){
           let subject = child.title;
           let optionValue = child.id;

           dropDownOptions.push({subject: subject, value: optionValue});
        
        }

        for (let option of dropDownOptions){
          let optionElement = document.createElement('option');
          optionElement.value = option.value;
          optionElement.text = option.subject;
          document.getElementById('childSubjects').appendChild(optionElement);
        }

        document.getElementById('childSubjects').addEventListener('change', function() {
          if(this.value == "home"){
            goHomePage();
          }else{
            setVisibleChild(this.value);
          }

          }
        );
      }
    </script>


    <script>
      function setVisibleChild(id){
        //quick flicker home to reset state, this allows hoping between child views
     
    
           let topNode = document.getElementById('content');
           let parentNode = document.getElementById('parentContent');
           let childVisibleNode = document.getElementById(id);
           let childDivs = document.getElementById('childDivs');
           for (let child of childDivs.children){
            if(child.id != id){
              child.hidden = true;
            }else{
              child.hidden = false; //redudant
            }
           }
           parentNode.hidden = true;
           childVisibleNode.hidden = false;
         }
      
    </script>

    <script>
      function goHomePage(){
         let topNode = document.getElementById('content');
         let parentNode = document.getElementById('parentContent');
         let children = document.getElementById('childDivs');
         for (let child of children.children){
            child.hidden = true;
         }
         parentNode.hidden = false;
      }
    </script>

    <script>
      function setChildLinks(){
        let children = document.getElementById('childDivs'); 
        let childSubjects = [];
        let discoveredMatches = [];

        
        for (let child of children.children){
          let subject = child.title;
          childSubjects.push({subject: subject, child: child});
          }
             
          let parentNodeH2Subjects = []
          let parentNodeH3Subjects = []
          let parentNodeH4Subjects = []
          let parentNode = document.getElementById('parentContent');
          let H2s = parentNode.getElementsByTagName("H2");
          let H3s = parentNode.getElementsByTagName("H3");
          let H4s = parentNode.getElementsByTagName("H4");
          let isH2Match = false;
          let isH3Match = false;
          let isH4Match = false;

          H2s.length > 0? parentNodeH2Subjects = H2s.map(item => ({subject: item.innerText, item: item})):isH2Match = false;
          H3s.length > 0?parentNodeH3Subjects = H3s.map(item => ({subject: item.innerText, item: item})):isH3Match = false;
          H4s.length > 0?parentNodeH4Subjects = H4s.map(item => ({subject: item.innerText, item: item})):isH4Match = false;

          
           isH3Match = H3s.length == childSubjects.length;
           isH2Match = H2s.length == childSubjects.length;
           isH4Match = H4s.length == childSubjects.length;
          let allDiscovered = false;

          if (isH3Match){
            //We have a match.  We need to find the H2s
            allDiscovered = true;
          }
          if (isH2Match){
            //We have a match.  We need to find the H3s
            allDiscovered = true;
          }
          if (isH4Match){
            //We have a match.  We need to find the H2s
            allDiscovered = true;
          }

          if(allDiscovered && (isH3Match + isH2Match + isH4Match) > 1){
            //wierd.  ok we work from scratch.
            allDiscovered = false;
          }

          if(!allDiscovered){

            let fluffWords = ["a", "an", "the", "and", "but", "or", "for", "nor", "on", "at", "to", "from", "by", "with", "of"];
            let fluffWordsRegex = new RegExp(fluffWords.join("|"), "g");
          
          //OK time to stumble through unpredictable llm output
          //First check if the child subjects are in the parent node h2 subjects
          let isH2 = false;
          let isH3 = false;
          let isH4 = false;
      
          //This can be optimized later.  Probably doesnt matter since it is client side with modern computing.
          for (let i = 0; i < parentNodeH2Subjects.length; i++){
            let subject = parentNodeH2Subjects[i].subject;
            for (let j = 0; j < childSubjects.length; j++){
              let childSubject = childSubjects[j].subject;
              if(childSubject.replace(fluffWordsRegex, "") == subject.replace(fluffWordsRegex, "")){
                isH2 = true;
                discoveredMatches.push({parentLink: parentNodeH2Subjects[i].item, childLink: childSubjects[j].child});
              }
            }

          }
         
          if(!isH2){
            for (let i = 0; i < parentNodeH3Subjects.length; i++){
              let subject = parentNodeH3Subjects[i].subject;
              for (let j = 0; j < childSubjects.length; j++){
                let childSubject = childSubjects[j].subject;  
                if(childSubject.replace(fluffWordsRegex, "") == subject.replace(fluffWordsRegex, "")){
                  isH3 = true;
                  discoveredMatches.push({parentLink: parentNodeH3Subjects[i].item, childLink: childSubjects[j].child});
                }
              }
            }
          }

          if(!isH3){
            for (let i = 0; i < parentNodeH4Subjects.length; i++){
              let subject = parentNodeH4Subjects[i].subject;
              for (let j = 0; j < childSubjects.length; j++){
                let childSubject = childSubjects[j].subject;
                if(childSubject.replace(fluffWordsRegex, "") == subject.replace(fluffWordsRegex, "")){
                  isH4 = true;
                  discoveredMatches.push({parentLink: parentNodeH4Subjects[i].item, childLink: childSubjects[j].child});
                }
              }
            }
          }

          if(!isH4){
              //I suppose there are edge cases but this surely covers 99.9% of the cases.
          }

          }else{
            if(isH3Match){
              for (let i = 0; i < parentNodeH3Subjects.length; i++){
                let child = childSubjects[i].child;
                makeChildLinks(parentNodeH3Subjects[i].item, child);
              }
              return; //bye bye
            }
            if(isH2Match){
              for (let i = 0; i < parentNodeH2Subjects.length; i++){
                let child = childSubjects[i].child;
                makeChildLinks(parentNodeH2Subjects[i].item, child);
                return; //bye bye
              }
              if(isH4Match){
                for (let i = 0; i < parentNodeH4Subjects.length; i++){
                  let child = childSubjects[i].child;
                  makeChildLinks(parentNodeH4Subjects[i].item, child);
                }
              }

            }

          }

          for (let match of discoveredMatches){
            makeChildLinks(match.parentLink, match.childLink);
            if(match.length < childSubjects.length){ alert("LLMM added additional info that is hidden");}
          }

        }
    </script>

    <script>
       function makeChildLinks(parent, child){
            parent.style.cursor = "pointer";
            parent.style.textDecoration = "underline";
            parent.style.color = "blue";
            parent.onclick = function(){
              setVisibleChild(child.id);
            }
       }

    </script>

<script>window.onload = setChildSubjects;</script>

</body>
</html>


   
    <!-- <textarea id="userPrompt"></textarea>

    <script>
        function nextButton() {
            const userPrompt = document.getElementById('userPrompt').value;
            console.log(userPrompt);
        }
    </script> -->