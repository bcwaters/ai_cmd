<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Home Page</title>
</head>
<body>
  <nav>
    <button id="saveButton" onclick="saveButton()">Save html</button>
    <a id="parentContentLink" href='javascript:goHomePage()'>Home</a>
    <select id="childSubjects">
      <option value="home">Home</option>
      <!-- Children are added here onload with setChildSubjects -->
    </select>
    <!-- Add a previous and next button for prior requests? -->
    <!-- Add a button to save the current page as a markdown file -->
  </nav>

  <div id="content">  
    <div id="parentContent">
        <h2>Jest Principles</h2>
<h3>1. <strong>Snapshot Testing</strong></h3>
<p>Snapshot testing in Jest is a powerful feature for ensuring the consistency of UI components. By capturing the rendered output of a component and comparing it against a reference snapshot, developers can easily detect unintended changes. This method is efficient for UI testing, integrates well with version control, and allows for customization of what gets included in the snapshot.</p>
<h3>2. <strong>Unit Testing with Mocks</strong></h3>
<p>Jest supports unit testing by allowing developers to use mock functions and modules. This principle is crucial for isolating the component or function being tested, enabling the simulation of return values, errors, and the mocking of entire modules. This approach enhances test isolation and makes it easier to test business logic without dependencies on external systems.</p>

    </div>
    <div id="childDivs">
      <div title="Snapshot Testing" id="childContent1" onclick="setVisibileChild('childContent1')" hidden=true><h2>Snapshot Testing in Jest: A Detailed Overview</h2>
<h3>Introduction to Snapshot Testing</h3>
<p>Snapshot testing in Jest is a technique used to ensure the consistency of UI components by capturing their rendered output and comparing it against a reference snapshot. This method is particularly useful for detecting unintended changes in the UI, making it an essential tool for developers working on user interfaces.</p>
<h3>How Snapshot Testing Works</h3>
<p>When a test runs, Jest takes the rendered output of a UI component and saves it as a snapshot file. This file serves as a reference point for future tests. Here's a step-by-step breakdown of the process:</p>
<ol>
<li><strong>Rendering the Component</strong>: The test case renders the UI component under test.</li>
<li><strong>Capturing the Snapshot</strong>: Jest captures the rendered output and saves it as a <code>.snap</code> file in a <code>__snapshots__</code> directory.</li>
<li><strong>Comparing with Reference</strong>: During subsequent test runs, Jest compares the new rendered output against the existing snapshot.</li>
<li><strong>Detecting Changes</strong>: If there are any differences, Jest will fail the test and display the differences, allowing developers to review and decide whether to update the snapshot or fix the code.</li>
</ol>
<h3>Benefits of Snapshot Testing</h3>
<h4>Efficiency in UI Testing</h4>
<p>Snapshot testing is highly efficient for UI testing because it automates the process of verifying that the UI has not changed unexpectedly. This saves developers from manually inspecting each component's output, which can be time-consuming, especially for complex UIs.</p>
<h4>Integration with Version Control</h4>
<p>Snapshots are stored in version control systems alongside the code. This integration allows developers to track changes in UI components over time and review them as part of the code review process. It also makes it easier to understand the impact of code changes on the UI.</p>
<h4>Customization and Flexibility</h4>
<p>Jest provides options to customize what gets included in the snapshot. Developers can choose to ignore certain properties or focus on specific parts of the UI. This flexibility is crucial for handling dynamic content or for testing only the parts of the UI that are critical to the application's functionality.</p>
<h3>Best Practices for Snapshot Testing</h3>
<h4>Regularly Review Snapshots</h4>
<p>It's important to regularly review snapshots to ensure they are up-to-date and reflect the intended UI. Outdated snapshots can lead to false positives in tests.</p>
<h4>Use Snapshots Judiciously</h4>
<p>Snapshots should be used for components where the exact output is critical. For components with highly dynamic content, consider using other testing methods or customizing the snapshot to focus on the static parts of the UI.</p>
<h4>Handle Snapshot Updates Carefully</h4>
<p>When a test fails due to a snapshot mismatch, carefully review the changes before updating the snapshot. This helps prevent unintended UI changes from being overlooked.</p>
<h4>Example of Snapshot Testing in Jest</h4>
<p>Here's an example of how to implement snapshot testing in Jest for a React component:</p>
<pre><code class="language-javascript">import React from 'react';
import renderer from 'react-test-renderer';
import MyComponent from './MyComponent';

</code><p><code class="language-javascript">test('MyComponent renders correctly', () =&gt; {
  const tree = renderer
    .create(&lt;MyComponent /&gt;)
    .toJSON();
  expect(tree).toMatchSnapshot();
});
</code></p></pre><p></p>
<p>In this example, <code>renderer.create(&lt;MyComponent /&gt;)</code> renders the component, and <code>.toJSON()</code> converts the rendered output into a format that can be saved as a snapshot. The <code>expect(tree).toMatchSnapshot()</code> assertion checks if the rendered output matches the existing snapshot.</p>
<h3>Conclusion</h3>
<p>Snapshot testing in Jest is a robust method for ensuring UI consistency. By capturing and comparing the rendered output of UI components, developers can efficiently detect unintended changes, integrate testing with version control, and customize the testing process to suit their needs. Following best practices ensures that snapshot testing remains a reliable and effective tool in the development workflow.</p>
<p>ResponseID:eac41d4f-b2e2-46</p>
</div><div title="Unit Testing with Mocks" id="childContent2" onclick="setVisibileChild('childContent2')" hidden=true><h2>Unit Testing with Mocks in Jest</h2>
<h3>Overview</h3>
<p>Unit testing with mocks in Jest is a critical technique for isolating the unit of code under test. This isolation allows developers to focus on the behavior of a specific component or function without the interference of external dependencies. By using mocks, developers can simulate the behavior of these dependencies, making tests more reliable and easier to maintain.</p>
<h3>Mock Functions</h3>
<p>Mock functions in Jest are used to replace real functions with simulated ones. They are created using <code>jest.fn()</code> and can be configured to return specific values, throw errors, or even call a real function if needed. Here are some key aspects of mock functions:</p>
<ul>
<li><p><strong>Return Values</strong>: You can specify what a mock function should return when called. This is useful for simulating successful API responses or database queries.</p>
<pre><code class="language-javascript">const mockFunction = jest.fn().mockReturnValue('mocked response');
</code></pre>
</li>
<li><p><strong>Error Simulation</strong>: Mock functions can be set to throw errors, which is useful for testing error handling paths in your code.</p>
<pre><code class="language-javascript">const mockFunction = jest.fn().mockImplementation(() =&gt; {
  throw new Error('Mocked error');
});
</code></pre>
</li>
<li><p><strong>Call Tracking</strong>: Jest provides detailed information about how a mock function was called, including the number of calls, arguments passed, and the context of the call. This helps in verifying that the function under test interacts correctly with its dependencies.</p>
<pre><code class="language-javascript">mockFunction.mock.calls; // Array of calls
</code></pre>
</li>
</ul>
<h3>Mock Modules</h3>
<p>Jest allows you to mock entire modules, which is particularly useful when you need to isolate the module being tested from its dependencies. There are two primary ways to mock modules in Jest:</p>
<ul>
<li><p><strong>Manual Mocks</strong>: You can create a manual mock by placing a file in a <code>__mocks__</code> directory that mirrors the structure of the module you want to mock. This approach gives you fine-grained control over the mock behavior.</p>
<pre><code class="language-javascript">// __mocks__/moduleName.js
const mockModule = jest.genMockFromModule('../moduleName');
mockModule.functionToMock = jest.fn();
module.exports = mockModule;
</code></pre>
</li>
<li><p><strong>Automatic Mocks</strong>: Jest can automatically mock modules without the need for manual mock files. This is done using <code>jest.mock('moduleName')</code>. Automatic mocks are useful for quick tests but offer less control over the mock behavior.</p>
<pre><code class="language-javascript">jest.mock('moduleName');
const moduleName = require('moduleName');
moduleName.functionToMock.mockReturnValue('mocked result');
</code></pre>
</li>
</ul>
<h3>Enhancing Test Isolation</h3>
<p>By using mocks, you can ensure that your tests are not affected by external factors such as network conditions or database availability. This isolation is crucial for:</p>
<ul>
<li><strong>Consistency</strong>: Tests run the same way every time, regardless of external conditions.</li>
<li><strong>Speed</strong>: Tests run faster because they do not depend on external systems.</li>
<li><strong>Reliability</strong>: Tests are less prone to failures caused by external dependencies.</li>
</ul>
<h3>Testing Business Logic</h3>
<p>Mocks allow you to test the core logic of your application without worrying about the integration with external systems. This means you can focus on:</p>
<ul>
<li><strong>Algorithmic Logic</strong>: Testing the correctness of algorithms and business rules.</li>
<li><strong>Error Handling</strong>: Ensuring that your code properly handles different types of errors.</li>
<li><strong>Edge Cases</strong>: Verifying how your code behaves under unusual or boundary conditions.</li>
</ul>
<h3>Best Practices</h3>
<p>To get the most out of unit testing with mocks in Jest, consider the following best practices:</p>
<ul>
<li><p><strong>Use Mocks Judiciously</strong>: Only mock what is necessary to isolate the unit under test. Over-mocking can lead to tests that are too brittle.</p>
</li>
<li><p><strong>Test Real Implementations</strong>: When possible, use real implementations in your tests to ensure that your mocks accurately reflect the behavior of the actual code.</p>
</li>
<li><p><strong>Clear Mock State</strong>: Always clear the state of mocks between tests to prevent test pollution.</p>
<pre><code class="language-javascript">afterEach(() =&gt; {
  jest.clearAllMocks();
});
</code></pre>
</li>
<li><p><strong>Document Mocking Strategy</strong>: Keep a clear documentation of your mocking strategy to ensure that other developers understand the intent and behavior of your tests.</p>
</li>
</ul>
<p>By following these principles and practices, you can effectively use unit testing with mocks in Jest to ensure the reliability and correctness of your code.</p>
<p>ResponseID:6905ee9a-516c-41</p>
</div>
    </div>
  </div>

    <script>
        function saveButton() {
          const content = document.documentElement.outerHTML; // Get the entire HTML content
          const blob = new Blob([content], { type: 'text/html' }); // Create a Blob from the content
          const url = URL.createObjectURL(blob); // Create a URL for the Blob
          const divInnerText = document.getElementById('content').innerText;
          let filename = divInnerText.substring(0, 25);
          const a = document.createElement('a'); // Create an anchor element
          a.href = url; // Set the href to the Blob URL
          
        a.download =  filename + '.html'; // Set the download attribute with a filename
          document.body.appendChild(a); // Append the anchor to the body
          a.click(); // Programmatically click the anchor to trigger the download
          document.body.removeChild(a); // Remove the anchor from the document
          URL.revokeObjectURL(url); // Release the Blob URL
        }
    </script>

    <script>
      function setChildSubjects(){
        let dropDownOptions = [];
        let childSubjects = document.getElementById('childDivs');
        for (let child of childSubjects.children){
           let subject = child.title;
           let optionValue = child.id;

           dropDownOptions.push({subject: subject, value: optionValue});
        
        }

        for (let option of dropDownOptions){
          let optionElement = document.createElement('option');
          optionElement.value = option.value;
          optionElement.text = option.subject;
          document.getElementById('childSubjects').appendChild(optionElement);
        }

        document.getElementById('childSubjects').addEventListener('change', function() {
          if(this.value == "home"){
            goHomePage();
          }else{
            setVisibleChild(this.value);
          }

          }
        );
      }
    </script>


    <script>
      function setVisibleChild(id){
        //quick flicker home to reset state, this allows hoping between child views
     
    
           let topNode = document.getElementById('content');
           let parentNode = document.getElementById('parentContent');
           let childVisibleNode = document.getElementById(id);
           let childDivs = document.getElementById('childDivs');
           for (let child of childDivs.children){
            if(child.id != id){
              child.hidden = true;
            }else{
              child.hidden = false; //redudant
            }
           }
           parentNode.hidden = true;
           childVisibleNode.hidden = false;
         }
      
    </script>

    <script>
      function goHomePage(){
         let topNode = document.getElementById('content');
         let parentNode = document.getElementById('parentContent');
         let children = document.getElementById('childDivs');
         for (let child of children.children){
            child.hidden = true;
         }
         parentNode.hidden = false;
      }
    </script>

    <script>
      function setChildLinks(){
        let children = document.getElementById('childDivs'); 
        let childSubjects = [];
        let discoveredMatches = [];

        
        for (let child of children.children){
          let subject = child.title;
          childSubjects.push({subject: subject, child: child});
          }
             
          let parentNodeH2Subjects = []
          let parentNodeH3Subjects = []
          let parentNodeH4Subjects = []
          let parentNode = document.getElementById('parentContent');
          let H2s = parentNode.getElementsByTagName("H2");
          let H3s = parentNode.getElementsByTagName("H3");
          let H4s = parentNode.getElementsByTagName("H4");
          let isH2Match = false;
          let isH3Match = false;
          let isH4Match = false;

          H2s.length > 0? parentNodeH2Subjects = H2s.map(item => ({subject: item.innerText, item: item})):isH2Match = false;
          H3s.length > 0?parentNodeH3Subjects = H3s.map(item => ({subject: item.innerText, item: item})):isH3Match = false;
          H4s.length > 0?parentNodeH4Subjects = H4s.map(item => ({subject: item.innerText, item: item})):isH4Match = false;

          
           isH3Match = H3s.length == childSubjects.length;
           isH2Match = H2s.length == childSubjects.length;
           isH4Match = H4s.length == childSubjects.length;
          let allDiscovered = false;

          if (isH3Match){
            //We have a match.  We need to find the H2s
            allDiscovered = true;
          }
          if (isH2Match){
            //We have a match.  We need to find the H3s
            allDiscovered = true;
          }
          if (isH4Match){
            //We have a match.  We need to find the H2s
            allDiscovered = true;
          }

          if(allDiscovered && (isH3Match + isH2Match + isH4Match) > 1){
            //wierd.  ok we work from scratch.
            allDiscovered = false;
          }

          if(!allDiscovered){

            let fluffWords = ["a", "an", "the", "and", "but", "or", "for", "nor", "on", "at", "to", "from", "by", "with", "of"];
            let fluffWordsRegex = new RegExp(fluffWords.join("|"), "g");
          
          //OK time to stumble through unpredictable llm output
          //First check if the child subjects are in the parent node h2 subjects
          let isH2 = false;
          let isH3 = false;
          let isH4 = false;
      
          //This can be optimized later.  Probably doesnt matter since it is client side with modern computing.
          for (let i = 0; i < parentNodeH2Subjects.length; i++){
            let subject = parentNodeH2Subjects[i].subject;
            for (let j = 0; j < childSubjects.length; j++){
              let childSubject = childSubjects[j].subject;
              if(childSubject.replace(fluffWordsRegex, "") == subject.replace(fluffWordsRegex, "")){
                isH2 = true;
                discoveredMatches.push({parentLink: parentNodeH2Subjects[i].item, childLink: childSubjects[j].child});
              }
            }

          }
         
          if(!isH2){
            for (let i = 0; i < parentNodeH3Subjects.length; i++){
              let subject = parentNodeH3Subjects[i].subject;
              for (let j = 0; j < childSubjects.length; j++){
                let childSubject = childSubjects[j].subject;  
                if(childSubject.replace(fluffWordsRegex, "") == subject.replace(fluffWordsRegex, "")){
                  isH3 = true;
                  discoveredMatches.push({parentLink: parentNodeH3Subjects[i].item, childLink: childSubjects[j].child});
                }
              }
            }
          }

          if(!isH3){
            for (let i = 0; i < parentNodeH4Subjects.length; i++){
              let subject = parentNodeH4Subjects[i].subject;
              for (let j = 0; j < childSubjects.length; j++){
                let childSubject = childSubjects[j].subject;
                if(childSubject.replace(fluffWordsRegex, "") == subject.replace(fluffWordsRegex, "")){
                  isH4 = true;
                  discoveredMatches.push({parentLink: parentNodeH4Subjects[i].item, childLink: childSubjects[j].child});
                }
              }
            }
          }

          if(!isH4){
              //I suppose there are edge cases but this surely covers 99.9% of the cases.
          }

          }else{
            if(isH3Match){
              for (let i = 0; i < parentNodeH3Subjects.length; i++){
                let child = childSubjects[i].child;
                makeChildLinks(parentNodeH3Subjects[i].item, child);
              }
              return; //bye bye
            }
            if(isH2Match){
              for (let i = 0; i < parentNodeH2Subjects.length; i++){
                let child = childSubjects[i].child;
                makeChildLinks(parentNodeH2Subjects[i].item, child);
                return; //bye bye
              }
              if(isH4Match){
                for (let i = 0; i < parentNodeH4Subjects.length; i++){
                  let child = childSubjects[i].child;
                  makeChildLinks(parentNodeH4Subjects[i].item, child);
                }
              }

            }

          }

          for (let match of discoveredMatches){
            makeChildLinks(match.parentLink, match.childLink);
            if(match.length < childSubjects.length){ alert("LLMM added additional info that is hidden");}
          }

        }
    </script>

    <script>
       function makeChildLinks(parent, child){
            parent.style.cursor = "pointer";
            parent.style.textDecoration = "underline";
            parent.style.color = "blue";
            parent.onclick = function(){
              setVisibleChild(child.id);
            }
       }

    </script>

<script>window.onload = setChildSubjects;</script>

</body>
</html>


   
    <!-- <textarea id="userPrompt"></textarea>

    <script>
        function nextButton() {
            const userPrompt = document.getElementById('userPrompt').value;
            console.log(userPrompt);
        }
    </script> -->