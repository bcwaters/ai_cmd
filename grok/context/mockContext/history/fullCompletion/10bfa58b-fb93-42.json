{"id":"10bfa58b-fb93-4207-b5df-766fc662e177","object":"chat.completion","created":1741067863,"model":"grok-2-1212","choices":[{"index":0,"message":{"role":"assistant","content":"# Cool JavaScript Functions\n\nHere are some cool JavaScript functions that can be useful in various scenarios:\n\n### 1. Debounce Function\n\nA debounce function is useful for limiting the rate at which a function can fire. It's often used for performance optimization in event handlers like scroll or resize events.\n\n```javascript\nfunction debounce(func, wait, immediate) {\n    var timeout;\n    return function() {\n        var context = this, args = arguments;\n        var later = function() {\n            timeout = null;\n            if (!immediate) func.apply(context, args);\n        };\n        var callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(context, args);\n    };\n};\n\n// Usage\nvar myEfficientFn = debounce(function() {\n    // All the taxing stuff you do\n}, 250);\nwindow.addEventListener('resize', myEfficientFn);\n```\n\n### 2. Throttle Function\n\nSimilar to debounce, throttle ensures a function doesn't get called more frequently than you want. It's useful for things like scroll or mouse move events.\n\n```javascript\nfunction throttle(func, limit) {\n    let lastFunc;\n    let lastRan;\n    return function() {\n        const context = this;\n        const args = arguments;\n        if (!lastRan) {\n            func.apply(context, args);\n            lastRan = Date.now();\n        } else {\n            clearTimeout(lastFunc);\n            lastFunc = setTimeout(function() {\n                if ((Date.now() - lastRan) >= limit) {\n                    func.apply(context, args);\n                    lastRan = Date.now();\n                }\n            }, limit - (Date.now() - lastRan));\n        }\n    }\n}\n\n// Usage\nvar throttled = throttle(function() {\n    console.log('Throttled!');\n}, 1000);\nwindow.addEventListener('scroll', throttled);\n```\n\n### 3. Memoization\n\nMemoization is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again.\n\n```javascript\nfunction memoize(fn) {\n    const cache = new Map();\n    return function(...args) {\n        const key = JSON.stringify(args);\n        if (cache.has(key)) {\n            return cache.get(key);\n        }\n        const result = fn.apply(this, args);\n        cache.set(key, result);\n        return result;\n    }\n}\n\n// Usage\nconst factorial = memoize(function(n) {\n    if (n === 0 || n === 1) return 1;\n    return n * factorial(n - 1);\n});\nconsole.log(factorial(5)); // calculates\nconsole.log(factorial(5)); // returns cached result\n```\n\n### 4. Deep Clone\n\nCreating a deep clone of an object can be useful for not mutating the original data when working with complex data structures.\n\n```javascript\nfunction deepClone(obj) {\n    if (obj === null || typeof obj !== 'object') return obj;\n    let copy = Array.isArray(obj) ? [] : {};\n    for (let key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            copy[key] = deepClone(obj[key]);\n        }\n    }\n    return copy;\n}\n\n// Usage\nconst original = { a: 1, b: { c: 2 } };\nconst clone = deepClone(original);\nclone.b.c = 3;\nconsole.log(original.b.c); // 2\nconsole.log(clone.b.c); // 3\n```\n\n### 5. Curry Function\n\nCurrying transforms a function of multiple arguments into a sequence of functions each with a single argument.\n\n```javascript\nfunction curry(fn) {\n    return function curried(...args) {\n        if (args.length >= fn.length) {\n            return fn.apply(this, args);\n        } else {\n            return function(...args2) {\n                return curried.apply(this, args.concat(args2));\n            }\n        }\n    };\n}\n\n// Usage\nfunction sum(a, b, c) {\n    return a + b + c;\n}\nlet curriedSum = curry(sum);\nconsole.log(curriedSum(1)(2)(3)); // 6\nconsole.log(curriedSum(1, 2)(3)); // 6\nconsole.log(curriedSum(1)(2, 3)); // 6\n```\n\nThese functions are not only cool but also very practical in real-world applications, especially when optimizing performance or handling complex data operations.@EOF@[JavaScript, functions, debounce, throttle, memoization, deepClone, curry, optimization, performance, eventHandling]","refusal":null},"finish_reason":"stop"}],"usage":{"prompt_tokens":271,"completion_tokens":954,"total_tokens":1225,"prompt_tokens_details":{"text_tokens":271,"audio_tokens":0,"image_tokens":0,"cached_tokens":0}},"system_fingerprint":"fp_5c0c5bd9d9"}